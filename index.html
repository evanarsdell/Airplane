<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Prevent native pinch zoom and ensure proper mobile scaling -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile Flight Simulator - Revised Chase Camera & Zoom</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* Disable touch actions so the mobile browser doesn't perform page zoom */
      touch-action: none;
      background: #87CEEB; /* Sky blue fallback */
      font-family: sans-serif;
    }
    /* Throttle slider container fixed at the bottom-right */
    #throttleContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
    /* Motion permission button (for iOS) */
    #motionButton {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      z-index: 10;
      cursor: pointer;
    }
  </style>
  <!-- Import map: Load Three.js and the GLTFLoader as ES modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>
</head>
<body>
  <!-- Button for motion (accelerometer) permission on iOS -->
  <button id="motionButton">Enable Motion Controls</button>
  <!-- Throttle slider UI fixed at the bottom-right -->
  <div id="throttleContainer">
    <label for="throttle">Throttle</label>
    <input type="range" id="throttle" min="0" max="5" step="0.1" value="1">
  </div>
  <!-- All game code inside this module script -->
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    let scene, camera, renderer, plane;
    let clock, forwardSpeed = 1;
    const throttle = document.getElementById("throttle");

    // Device orientation values (in degrees)
    let deviceBeta = 0, deviceGamma = 0;

    // Camera chase settings:
    // - Increase defaultTrailingDistance so the camera starts further behind the plane.
    const defaultTrailingDistance = 30;
    let currentTrailingDistance = defaultTrailingDistance;
    const cameraVerticalOffset = 5;

    // Variables for pinch gesture handling
    let isPinching = false;
    let initialPinchDistance = 0;
    let initialTrailingDistance = currentTrailingDistance;

    // Initialize scene, camera, lights, and objects.
    function init() {
      // Create the scene with a blue-sky background.
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      // Setup perspective camera.
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

      // Create the WebGL renderer.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Add ambient and directional lighting.
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 100);
      scene.add(directionalLight);

      // Create a large green ground.
      const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
      const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Create a runway strip right under the spawn point.
      const runwayWidth = 10, runwayLength = 200;
      const runwayGeometry = new THREE.PlaneGeometry(runwayWidth, runwayLength);
      const runwayMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
      runway.rotation.x = -Math.PI / 2;
      runway.position.set(0, 0.02, 0);
      scene.add(runway);

      // Load the 3D plane model from models/plane.glb.
      const loader = new GLTFLoader();
      loader.load(
        "models/plane.glb",
        function (gltf) {
          plane = gltf.scene;
          // Set the initial position higher and ensure its orientation is reset.
          plane.position.set(0, 5, 0);
          plane.rotation.set(0, 0, 0);
          scene.add(plane);
          // Update the camera immediately.
          updateCamera(0);
        },
        undefined,
        function (error) {
          console.error("Error loading the plane model:", error);
        }
      );

      clock = new THREE.Clock();
      window.addEventListener("resize", onWindowResize);
    }

    // Adjust renderer and camera on window resize.
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Update the camera so it trails the plane in a classic third-person view.
    function updateCamera(delta) {
      if (!plane) return;

      // When not actively pinching, smoothly reset to the default trailing distance.
      if (!isPinching) {
        currentTrailingDistance = THREE.MathUtils.lerp(currentTrailingDistance, defaultTrailingDistance, delta * 0.5);
      }

      // Obtain the forward direction of the plane.
      const forwardDir = new THREE.Vector3();
      plane.getWorldDirection(forwardDir);

      // Compute desired camera position:
      // Start at the plane's position, add upward offset, and subtract the forward direction scaled by currentTrailingDistance.
      const desiredPosition = new THREE.Vector3().copy(plane.position)
        .add(new THREE.Vector3(0, cameraVerticalOffset, 0))
        .sub(forwardDir.multiplyScalar(currentTrailingDistance));

      // Smoothly interpolate the camera's position.
      camera.position.lerp(desiredPosition, 0.1);

      // Set the camera look target slightly ahead of the plane.
      const desiredLookAt = new THREE.Vector3().copy(plane.position).add(forwardDir);
      camera.lookAt(desiredLookAt);
    }

    // Handle device orientation events (for tilting/steering).
    function handleOrientation(event) {
      deviceBeta = event.beta || 0;
      deviceGamma = event.gamma || 0;
    }

    // Request iOS motion permission when the button is clicked.
    const motionButton = document.getElementById("motionButton");
    motionButton.addEventListener("click", function () {
      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === "granted") {
              window.addEventListener("deviceorientation", handleOrientation);
              motionButton.style.display = "none";
            }
          })
          .catch(console.error);
      } else {
        window.addEventListener("deviceorientation", handleOrientation);
        motionButton.style.display = "none";
      }
    });

    // Pinch gesture detection for zooming the chase camera.
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    document.addEventListener("touchstart", function (e) {
      if (e.touches.length === 2) {
        isPinching = true;
        initialPinchDistance = getPinchDistance(e.touches);
        initialTrailingDistance = currentTrailingDistance;
      }
    }, { passive: false });

    document.addEventListener("touchmove", function (e) {
      if (isPinching && e.touches.length === 2) {
        e.preventDefault(); // Prevent native pinch-zoom.
        const currentDistance = getPinchDistance(e.touches);
        const scale = currentDistance / initialPinchDistance;
        // Apply a nonlinear sensitivity adjustment (exponent 1.5)
        currentTrailingDistance = initialTrailingDistance * Math.pow(scale, 1.5);
        // Clamp between a min and max distance.
        currentTrailingDistance = Math.min(Math.max(currentTrailingDistance, 20), 60);
      }
    }, { passive: false });

    document.addEventListener("touchend", function (e) {
      if (e.touches.length < 2) {
        isPinching = false;
      }
    }, { passive: false });

    // Main animation loop.
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (plane) {
        // Update the plane's speed from the throttle slider.
        forwardSpeed = parseFloat(throttle.value);

        // Use device orientation (beta and gamma) for steering.
        const desiredPitch = THREE.MathUtils.degToRad(deviceBeta);
        const desiredRoll = THREE.MathUtils.degToRad(deviceGamma);

        // Smoothly adjust the plane's pitch and roll.
        plane.rotation.x = THREE.MathUtils.lerp(plane.rotation.x, desiredPitch, 0.1);
        plane.rotation.z = THREE.MathUtils.lerp(plane.rotation.z, -desiredRoll, 0.1);

        // Yaw adjustment influenced by roll.
        plane.rotation.y -= desiredRoll * delta * 0.5;

        // Move the plane forward along its local negative Z-axis.
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(plane.quaternion);
        plane.position.add(forward.multiplyScalar(forwardSpeed * delta));
      }

      updateCamera(delta);
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
