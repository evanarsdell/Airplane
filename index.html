<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Mobile Responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile 2.5D Flight Simulator</title>
  <style>
    /* Reset default margins and paddings */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }
    /* Full-screen canvas */
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }
    /* Portrait mode overlay message */
    @media only screen and (orientation: portrait) {
      body::before {
        content: "Please rotate your device to landscape mode for best experience";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 1.5em;
        z-index: 1000;
      }
    }
    /* Throttle control UI */
    #throttleControl {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      border: 2px solid #333;
      text-align: center;
      line-height: 80px;
      font-weight: bold;
      user-select: none;
      z-index: 10;
      touch-action: none;
    }
    /* HUD display */
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 10;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Canvas element for rendering the game -->
  <canvas id="gameCanvas"></canvas>
  <!-- Throttle control for adjusting engine power -->
  <div id="throttleControl">0%</div>
  <!-- HUD for displaying flight data -->
  <div id="hud">Speed: 0<br>Altitude: 0</div>

  <script>
    "use strict";
    /**************************************
     * Game State Constants
     **************************************/
    const GAME_STATE = {
      LOADING: 'loading',
      ACTIVE: 'active',
      GAME_OVER: 'game_over'
    };

    /**************************************
     * Utility Function: clamp
     **************************************/
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    /**************************************
     * InputHandler Module
     * - Listens for DeviceOrientation events to capture gyroscopic data.
     * - Processes touch events on the throttle control element.
     **************************************/
    class InputHandler {
      constructor(throttleElement) {
        this.pitch = 0;   // Up/down tilt
        this.roll = 0;    // Left/right tilt
        this.deadZone = 3; // Degrees to ignore minor movements
        this.throttle = 0; // Engine throttle from 0 to 100%
        this.throttleElement = throttleElement;
        this.initOrientation();
        this.initThrottle();
      }

      initOrientation() {
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', (event) => {
            // beta: front-back tilt, gamma: left-right tilt
            let rawPitch = event.beta || 0;
            let rawRoll = event.gamma || 0;
            // Apply dead zone to avoid jitter
            this.pitch = (Math.abs(rawPitch) > this.deadZone) ? rawPitch : 0;
            this.roll = (Math.abs(rawRoll) > this.deadZone) ? rawRoll : 0;
          }, true);
        } else {
          console.warn("DeviceOrientationEvent not supported");
        }
      }

      initThrottle() {
        let startY = 0;
        let initialThrottle = this.throttle;
        const onTouchStart = (e) => {
          e.preventDefault();
          startY = e.touches[0].clientY;
          initialThrottle = this.throttle;
        };
        const onTouchMove = (e) => {
          e.preventDefault();
          let currentY = e.touches[0].clientY;
          let delta = startY - currentY; // Upward swipe increases throttle
          let sensitivity = 0.2; // Adjust sensitivity as needed
          this.throttle = clamp(initialThrottle + delta * sensitivity, 0, 100);
          this.updateThrottleUI();
        };
        this.throttleElement.addEventListener("touchstart", onTouchStart, false);
        this.throttleElement.addEventListener("touchmove", onTouchMove, false);
        // For desktop testing, allow click to increment throttle
        this.throttleElement.addEventListener("click", () => {
          this.throttle = (this.throttle + 10) % 110;
          this.updateThrottleUI();
        });
      }

      updateThrottleUI() {
        this.throttleElement.innerText = Math.round(this.throttle) + "%";
      }
    }

    /**************************************
     * PhysicsEngine Module
     * - Simulates flight dynamics: forward velocity, altitude, lift, drag, and gravity.
     * - Updates aircraft state based on throttle and gyroscopic input.
     **************************************/
    class PhysicsEngine {
      constructor() {
        // x: forward distance, y: altitude (starting at 100 units)
        this.position = { x: 0, y: 100 };
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        // Flight physics constants
        this.gravity = 0.3;      // Downward acceleration
        this.liftFactor = 0.1;   // Lift produced by pitch
        this.dragFactor = 0.005; // Drag affecting velocity
        this.enginePower = 0.5;  // Thrust multiplier
      }

      update(deltaTime, input) {
        // Forward acceleration: throttle force minus drag
        let throttleForce = input.throttle * this.enginePower * 0.01;
        this.acceleration.x = throttleForce - (this.dragFactor * this.velocity.x);
        // Vertical acceleration: lift (based on pitch) minus gravity and drag
        // Negative pitch gives upward lift (simulate natural control)
        let lift = -input.pitch * this.liftFactor;
        this.acceleration.y = lift - this.gravity - (this.dragFactor * this.velocity.y);

        // Update velocities and positions
        this.velocity.x += this.acceleration.x * deltaTime;
        this.velocity.y += this.acceleration.y * deltaTime;
        this.position.x += this.velocity.x * deltaTime;
        this.position.y += this.velocity.y * deltaTime;

        // Prevent going below ground (altitude 0)
        if (this.position.y < 0) {
          this.position.y = 0;
          this.velocity.y = 0;
        }
      }
    }

    /**************************************
     * Renderer Module
     * - Uses HTML5 Canvas to draw the environment with a 2.5D perspective.
     * - Draws the sky, ground, perspective runway, parallax environment objects, and the aircraft.
     **************************************/
    class Renderer {
      constructor(canvas, physics) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.physics = physics;
        this.structures = this.generateStructures(15);
        this.resize();
        window.addEventListener("resize", () => this.resize());
      }

      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }

      generateStructures(count) {
        // Generate random environmental objects for parallax effect
        let structures = [];
        for (let i = 0; i < count; i++) {
          structures.push({
            x: Math.random() * window.innerWidth,
            y: 100 + Math.random() * 300,
            size: 20 + Math.random() * 30,
            type: ["rect", "circle", "triangle"][Math.floor(Math.random() * 3)],
            color: ["#8B4513", "#A0522D", "#556B2F"][Math.floor(Math.random() * 3)]
          });
        }
        return structures;
      }

      drawBackground() {
        let ctx = this.ctx;
        let w = this.canvas.width, h = this.canvas.height;
        // Draw sky
        let skyGradient = ctx.createLinearGradient(0, 0, 0, h);
        skyGradient.addColorStop(0, "#87CEEB");
        skyGradient.addColorStop(1, "#87CEEB");
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, w, h);
        // Draw ground
        let groundGradient = ctx.createLinearGradient(0, h * 0.6, 0, h);
        groundGradient.addColorStop(0, "#228B22");
        groundGradient.addColorStop(1, "#006400");
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, h * 0.6, w, h * 0.4);
      }

      drawRunway() {
        let ctx = this.ctx;
        let w = this.canvas.width, h = this.canvas.height;
        ctx.save();
        // Use physics.position.x to simulate forward movement along the runway
        let offset = this.physics.position.x % w;
        let centerX = w / 2;
        let bottomY = h;
        let topY = h * 0.6;
        let bottomWidth = w * 0.8;
        let topWidth = w * 0.1;
        ctx.beginPath();
        ctx.moveTo(centerX - topWidth / 2, topY);
        ctx.lineTo(centerX + topWidth / 2, topY);
        ctx.lineTo(centerX + bottomWidth / 2, bottomY);
        ctx.lineTo(centerX - bottomWidth / 2, bottomY);
        ctx.closePath();
        ctx.fillStyle = "#333";
        ctx.fill();
        // Draw center line for runway
        ctx.strokeStyle = "#FFF";
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 20]);
        ctx.beginPath();
        ctx.moveTo(centerX, topY);
        ctx.lineTo(centerX, bottomY);
        ctx.stroke();
        ctx.restore();
      }

      drawStructures() {
        let ctx = this.ctx;
        let w = this.canvas.width, h = this.canvas.height;
        this.structures.forEach((struct) => {
          // Parallax: adjust position based on forward movement
          let relativeY = struct.y - (this.physics.position.x * 0.05) % 300;
          if (relativeY < 0) relativeY += 300;
          let scale = 1 + (300 - relativeY) / 600;
          let posX = struct.x * scale;
          let posY = h * 0.6 + relativeY;
          ctx.save();
          ctx.translate(posX, posY);
          ctx.scale(scale, scale);
          ctx.fillStyle = struct.color;
          switch (struct.type) {
            case "rect":
              ctx.fillRect(-struct.size / 2, -struct.size / 2, struct.size, struct.size);
              break;
            case "circle":
              ctx.beginPath();
              ctx.arc(0, 0, struct.size / 2, 0, Math.PI * 2);
              ctx.fill();
              break;
            case "triangle":
              ctx.beginPath();
              ctx.moveTo(0, -struct.size / 2);
              ctx.lineTo(-struct.size / 2, struct.size / 2);
              ctx.lineTo(struct.size / 2, struct.size / 2);
              ctx.closePath();
              ctx.fill();
              break;
          }
          ctx.restore();
        });
      }

      drawAircraft(input) {
        let ctx = this.ctx;
        let w = this.canvas.width, h = this.canvas.height;
        ctx.save();
        // Simulate a cockpit view: position aircraft near the bottom center
        ctx.translate(w / 2, h * 0.7);
        // Apply roll for banking effect
        ctx.rotate(input.roll * Math.PI / 180);
        // Draw a simple triangular aircraft
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(-10, 15);
        ctx.lineTo(10, 15);
        ctx.closePath();
        ctx.fillStyle = "#FF0";
        ctx.fill();
        ctx.restore();
      }

      render(input) {
        this.drawBackground();
        this.drawRunway();
        this.drawStructures();
        this.drawAircraft(input);
      }
    }

    /**************************************
     * UIController Module
     * - Updates the HUD with real-time flight data.
     **************************************/
    class UIController {
      constructor(hudElement) {
        this.hudElement = hudElement;
      }
      update(speed, altitude, throttle) {
        this.hudElement.innerHTML = 
          "Speed: " + speed.toFixed(1) + "<br>" +
          "Altitude: " + altitude.toFixed(1) + "<br>" +
          "Throttle: " + Math.round(throttle) + "%";
      }
    }

    /**************************************
     * GameEngine Module
     * - Main controller that manages game states, the main loop, and inter-module communication.
     **************************************/
    class GameEngine {
      constructor() {
        this.canvas = document.getElementById("gameCanvas");
        this.inputHandler = new InputHandler(document.getElementById("throttleControl"));
        this.physicsEngine = new PhysicsEngine();
        this.renderer = new Renderer(this.canvas, this.physicsEngine);
        this.uiController = new UIController(document.getElementById("hud"));
        this.state = GAME_STATE.ACTIVE;
        this.lastTime = performance.now();
        this.gameLoop = this.gameLoop.bind(this);
      }

      gameLoop(currentTime) {
        let deltaTime = (currentTime - this.lastTime) / 16.67; // Normalize to ~60fps
        this.lastTime = currentTime;

        if (this.state === GAME_STATE.ACTIVE) {
          // Update physics based on user input
          this.physicsEngine.update(deltaTime, this.inputHandler);
          // Check for crash condition: altitude has reached ground level (0)
          if (this.physicsEngine.position.y === 0) {
            this.state = GAME_STATE.GAME_OVER;
          }
        }

        // Render the frame and update HUD
        this.renderer.render(this.inputHandler);
        this.uiController.update(this.physicsEngine.velocity.x, this.physicsEngine.position.y, this.inputHandler.throttle);

        if (this.state === GAME_STATE.GAME_OVER) {
          this.displayGameOver();
        } else {
          requestAnimationFrame(this.gameLoop);
        }
      }

      displayGameOver() {
        let ctx = this.renderer.ctx;
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillStyle = "#FFF";
        ctx.font = "48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", this.canvas.width / 2, this.canvas.height / 2);
        ctx.restore();
      }

      start() {
        this.lastTime = performance.now();
        requestAnimationFrame(this.gameLoop);
      }
    }

    /**************************************
     * Initialize and Start the Game
     **************************************/
    document.addEventListener("DOMContentLoaded", () => {
      const game = new GameEngine();
      game.start();
    });
  </script>
</body>
</html>
