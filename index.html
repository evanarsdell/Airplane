<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple 3D Flight</title>
  <!-- Meta viewport for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    /* Orientation overlay */
    #orientationOverlay {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 10;
      padding: 20px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="orientationOverlay">
    <h2>Please rotate your device to landscape</h2>
  </div>
  
  <script>
    /* ====== Game Class ====== */
    class Game {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.lastTime = performance.now();
        // Initialize modules
        this.input = new InputHandler(this.canvas);
        this.physics = new Physics();
        this.renderer = new Renderer(this.canvas, this.ctx);
        this.throttleUI = new ThrottleUI(this.canvas, this.ctx, this.input);
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('orientationchange', () => this.resize());
        this.checkOrientation();
      }
      
      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.renderer.resize();
        this.throttleUI.resize();
        this.checkOrientation();
      }
      
      checkOrientation() {
        const overlay = document.getElementById('orientationOverlay');
        if (window.innerWidth < window.innerHeight) {
          overlay.style.display = 'flex';
        } else {
          overlay.style.display = 'none';
        }
      }
      
      start() {
        requestAnimationFrame((ts) => this.gameLoop(ts));
      }
      
      gameLoop(timestamp) {
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        // Update input and physics
        this.input.update();
        this.physics.update(dt, this.input);
        // Render environment and plane
        this.renderer.render(this.physics, this.input);
        this.throttleUI.render();
        requestAnimationFrame((ts) => this.gameLoop(ts));
      }
    }
    
    /* ====== InputHandler ====== */
    class InputHandler {
      constructor(canvas) {
        this.canvas = canvas;
        // Values from device orientation (in degrees)
        this.pitch = 0; // nose up/down (beta)
        this.roll = 0;  // tilt left/right (gamma)
        // Throttle value 0–100; default mid value.
        this.throttle = 50;
        // For throttle slider dragging
        this.sliding = false;
        this.sliderRect = { x: 0, y: 0, width: 0, height: 0 };
        // Bind events
        window.addEventListener('deviceorientation', (e) => this.handleOrientation(e));
        canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), {passive:false});
        canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), {passive:false});
        canvas.addEventListener('touchend', () => { this.sliding = false; });
      }
      
      handleOrientation(event) {
        // Use beta for pitch and gamma for roll.
        let beta = event.beta || 0;
        let gamma = event.gamma || 0;
        // Apply dead zone of ±3° and clamp to ±30°
        this.pitch = (Math.abs(beta) < 3) ? 0 : Math.max(-30, Math.min(30, beta));
        this.roll  = (Math.abs(gamma) < 3) ? 0 : Math.max(-30, Math.min(30, gamma));
      }
      
      handleTouchStart(e) {
        let touch = e.touches[0];
        let rect = this.canvas.getBoundingClientRect();
        let x = touch.clientX - rect.left;
        let y = touch.clientY - rect.top;
        // Check if touch is within slider area
        if (x >= this.sliderRect.x && x <= this.sliderRect.x + this.sliderRect.width &&
            y >= this.sliderRect.y && y <= this.sliderRect.y + this.sliderRect.height) {
          this.sliding = true;
          this.updateThrottleFromY(y);
          e.preventDefault();
        }
      }
      
      handleTouchMove(e) {
        if (this.sliding) {
          let touch = e.touches[0];
          let rect = this.canvas.getBoundingClientRect();
          let y = touch.clientY - rect.top;
          this.updateThrottleFromY(y);
          e.preventDefault();
        }
      }
      
      updateThrottleFromY(y) {
        // Map y within sliderRect to throttle (0 at bottom, 100 at top)
        let { y: top, height } = this.sliderRect;
        let relative = Math.max(0, Math.min(1, (top + height - y) / height));
        this.throttle = relative * 100;
      }
      
      update() {
        // (No smoothing applied for simplicity)
      }
    }
    
    /* ====== Physics ====== */
    class Physics {
      constructor() {
        // Starting aircraft state
        this.altitude = 100;     // meters
        this.forwardSpeed = 50;  // m/s base speed
        this.distance = 0;       // for ground scrolling
      }
      
      update(dt, input) {
        // Simple throttle: forward speed increases with throttle
        const targetSpeed = 50 + input.throttle; // base + throttle influence
        // Smooth approach to target speed
        this.forwardSpeed += (targetSpeed - this.forwardSpeed) * 0.5 * dt;
        this.distance += this.forwardSpeed * dt;
        // Altitude change based on pitch (normalized by ±30°)
        const climbRate = 20; // m/s at full pitch
        this.altitude += (input.pitch / 30) * climbRate * dt;
        // Prevent negative altitude
        if (this.altitude < 0) this.altitude = 0;
      }
    }
    
    /* ====== Renderer ====== */
    class Renderer {
      constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        // Horizon line (you can adjust this to taste)
        this.horizonY = canvas.height * 0.35;
        // Perspective parameters
        this.perspectiveScale = 200; // adjust to affect spacing
        this.gridSpacing = 50;       // world units between horizontal lines
        this.numGridLines = 30;
      }
      
      resize() {
        this.horizonY = this.canvas.height * 0.35;
      }
      
      render(physics, input) {
        const ctx = this.ctx;
        // Clear canvas
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // Draw sky
        let skyGrad = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        skyGrad.addColorStop(0, "#87CEFA");
        skyGrad.addColorStop(1, "#4682B4");
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Save state to apply roll to the ground grid (simulate turning)
        ctx.save();
        // Rotate entire ground based on input.roll (convert to radians)
        ctx.translate(this.canvas.width/2, this.horizonY);
        ctx.rotate(-input.roll * Math.PI / 180);
        ctx.translate(-this.canvas.width/2, -this.horizonY);
        
        // Draw ground grid (horizontal lines)
        let scrollOffset = physics.distance % this.gridSpacing;
        for (let i = 0; i < this.numGridLines; i++) {
          let worldZ = i * this.gridSpacing + scrollOffset;
          // Simple perspective projection: farther lines get closer to horizon.
          let lineY = this.horizonY + (this.canvas.height - this.horizonY) * (this.perspectiveScale / (worldZ + this.perspectiveScale));
          ctx.strokeStyle = "#444";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, lineY);
          ctx.lineTo(this.canvas.width, lineY);
          ctx.stroke();
        }
        
        // Draw runway edges as two converging lines
        let centerX = this.canvas.width / 2;
        // At bottom, runway is wide; at horizon, it converges to center.
        let runwayBottomWidth = this.canvas.width * 0.8;
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 2;
        // Left edge
        ctx.beginPath();
        ctx.moveTo(centerX, this.horizonY);
        ctx.lineTo(centerX - runwayBottomWidth/2, this.canvas.height);
        ctx.stroke();
        // Right edge
        ctx.beginPath();
        ctx.moveTo(centerX, this.horizonY);
        ctx.lineTo(centerX + runwayBottomWidth/2, this.canvas.height);
        ctx.stroke();
        
        ctx.restore();
        
        // Draw simple airplane (a triangle) in fixed position
        const planeX = this.canvas.width / 2;
        const planeY = this.canvas.height * 0.7;
        ctx.save();
        ctx.translate(planeX, planeY);
        // Rotate by roll so the plane tilts with the device.
        ctx.rotate(input.roll * Math.PI / 180);
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(20, 10);
        ctx.lineTo(-20, 10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    
    /* ====== ThrottleUI ====== */
    class ThrottleUI {
      constructor(canvas, ctx, input) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.input = input;
        // Define slider area (a simple vertical line with a draggable dot)
        this.margin = 40;
        this.sliderHeight = 100;
        this.sliderWidth = 4;
        this.dotRadius = 8;
        this.updateSliderRect();
        // Let the input know where the slider is (for touch hit-testing)
        this.input.sliderRect = Object.assign({}, this.sliderRect);
      }
      
      updateSliderRect() {
        this.sliderRect = {
          x: this.canvas.width - this.margin,
          y: this.canvas.height - this.sliderHeight - this.margin,
          width: this.sliderWidth,
          height: this.sliderHeight
        };
      }
      
      resize() {
        this.updateSliderRect();
        this.input.sliderRect = Object.assign({}, this.sliderRect);
      }
      
      render() {
        const ctx = this.ctx;
        // Draw slider line
        ctx.save();
        ctx.strokeStyle = "#FFF";
        ctx.lineWidth = this.sliderWidth;
        ctx.beginPath();
        ctx.moveTo(this.sliderRect.x + this.sliderWidth/2, this.sliderRect.y);
        ctx.lineTo(this.sliderRect.x + this.sliderWidth/2, this.sliderRect.y + this.sliderRect.height);
        ctx.stroke();
        // Draw dot representing throttle
        // Map throttle (0 at bottom, 100 at top) to dot Y position
        let t = this.input.throttle / 100;
        let dotY = this.sliderRect.y + this.sliderRect.height * (1 - t);
        ctx.fillStyle = "#FFF";
        ctx.beginPath();
        ctx.arc(this.sliderRect.x + this.sliderWidth/2, dotY, this.dotRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // Start the game
    const game = new Game();
    game.start();
  </script>
</body>
</html>
