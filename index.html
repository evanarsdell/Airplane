<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Prevent native pinch-zoom and ensure proper mobile scaling -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile Flight Simulator – Portrait Mode & Extended Chase Camera</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* Disable native pinch-zoom on the page */
      touch-action: none;
      background: #87CEEB;
      font-family: sans-serif;
    }
    /* Throttle slider container fixed at bottom-right */
    #throttleContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 8px;
      z-index: 20;
      display: none;
    }
    /* Motion permission button (for iOS) */
    #motionButton {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      z-index: 20;
      cursor: pointer;
      display: none;
    }
    /* Orientation overlay to instruct portrait mode */
    #orientationOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      font-size: 24px;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 50;
    }
  </style>
  <!-- Import map: Load Three.js and GLTFLoader as ES modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>
</head>
<body>
  <!-- Orientation overlay -->
  <div id="orientationOverlay">Rotate phone to portrait mode</div>
  <!-- Button for accelerometer permission (shown only in portrait) -->
  <button id="motionButton">Enable Motion Controls</button>
  <!-- Throttle slider UI (shown only in portrait) -->
  <div id="throttleContainer">
    <label for="throttle">Throttle</label>
    <input type="range" id="throttle" min="0" max="5" step="0.1" value="1">
  </div>
  <!-- All game code below in one module script -->
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    let scene, camera, renderer, plane;
    let clock, forwardSpeed = 1;
    const throttle = document.getElementById("throttle");

    // Device orientation baseline and relative values.
    let baselineSet = false;
    let baselineBeta = 0, baselineGamma = 0;
    let deviceBeta = 0, deviceGamma = 0;

    // Camera chase settings: place camera far behind the plane.
    const defaultTrailingDistance = 80;  // Increased trailing distance.
    let currentTrailingDistance = defaultTrailingDistance;
    const cameraVerticalOffset = 20;

    // Variables for pinch-zoom gesture.
    let isPinching = false;
    let initialPinchDistance = 0;
    let initialTrailingDistance = currentTrailingDistance;

    // Initialize scene, camera, lights, and objects.
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lighting.
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 100);
      scene.add(directionalLight);

      // Create a large green ground.
      const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
      const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Create runway: 10 units wide, 200 units long.
      // Shift geometry so that its near edge is at z = 0 (for takeoff) and extends in negative Z.
      const runwayWidth = 10, runwayLength = 200;
      const runwayGeometry = new THREE.PlaneGeometry(runwayWidth, runwayLength);
      runwayGeometry.translate(0, 0, -runwayLength / 2);
      const runwayMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
      runway.rotation.x = -Math.PI / 2;
      runway.position.set(0, 0.01, 0);
      scene.add(runway);

      // Load the 3D plane model.
      const loader = new GLTFLoader();
      loader.load(
        "models/plane.glb",
        function (gltf) {
          plane = gltf.scene;
          // Place the plane on the runway at its near edge (on the ground).
          plane.position.set(0, 0.05, 0);
          // No rotation change is needed since the model's nose already faces negative Z.
          plane.rotation.set(0, 0, 0);
          scene.add(plane);
          updateCamera(0);
        },
        undefined,
        function (error) {
          console.error("Error loading the plane model:", error);
        }
      );

      clock = new THREE.Clock();
      window.addEventListener("resize", onWindowResize);
      window.addEventListener("resize", checkOrientation);
      window.addEventListener("orientationchange", checkOrientation);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Check and enforce portrait orientation.
    function checkOrientation() {
      const overlay = document.getElementById("orientationOverlay");
      if (window.innerHeight >= window.innerWidth) { // Portrait.
        overlay.style.display = "none";
        document.getElementById("motionButton").style.display = "block";
        document.getElementById("throttleContainer").style.display = "block";
      } else { // Landscape.
        overlay.style.display = "flex";
        overlay.innerText = "Rotate phone to portrait mode";
        document.getElementById("motionButton").style.display = "none";
        document.getElementById("throttleContainer").style.display = "none";
      }
    }

    // Update the chase camera so it trails the plane from behind.
    // We use the plane’s yaw (ignoring pitch/roll) to compute a forward "nose" vector.
    function updateCamera(delta) {
      if (!plane) return;
      if (!isPinching) {
        currentTrailingDistance = THREE.MathUtils.lerp(currentTrailingDistance, defaultTrailingDistance, delta * 0.5);
      }
      const yaw = plane.rotation.y;
      // With the nose along negative Z at yaw=0.
      const noseDir = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
      // Place the camera behind the plane (opposite the nose) and add vertical offset.
      const cameraOffset = noseDir.clone().negate().multiplyScalar(currentTrailingDistance);
      cameraOffset.y = cameraVerticalOffset;
      const desiredPosition = new THREE.Vector3().copy(plane.position).add(cameraOffset);
      camera.position.lerp(desiredPosition, 0.1);
      // Look far ahead along the nose direction.
      const targetOffset = noseDir.clone().multiplyScalar(100);
      const targetPosition = new THREE.Vector3().copy(plane.position).add(targetOffset);
      targetPosition.y = plane.position.y + cameraVerticalOffset;
      camera.lookAt(targetPosition);
    }

    // Device orientation handler: subtract initial baseline so that the current neutral is zero.
    function handleOrientation(event) {
      if (!baselineSet) {
        baselineBeta = event.beta;
        baselineGamma = event.gamma;
        baselineSet = true;
      }
      deviceBeta = event.beta - baselineBeta;
      deviceGamma = event.gamma - baselineGamma;
    }

    // Request device motion (accelerometer) permissions on iOS.
    const motionButton = document.getElementById("motionButton");
    motionButton.addEventListener("click", function () {
      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === "granted") {
              window.addEventListener("deviceorientation", handleOrientation);
              motionButton.style.display = "none";
            }
          })
          .catch(console.error);
      } else {
        window.addEventListener("deviceorientation", handleOrientation);
        motionButton.style.display = "none";
      }
    });

    // Pinch gesture handling for zooming the chase camera.
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    document.addEventListener("touchstart", function (e) {
      if (e.touches.length === 2) {
        isPinching = true;
        initialPinchDistance = getPinchDistance(e.touches);
        initialTrailingDistance = currentTrailingDistance;
      }
    }, { passive: false });
    document.addEventListener("touchmove", function (e) {
      if (isPinching && e.touches.length === 2) {
        e.preventDefault(); // Prevent native pinch-zoom.
        const currentDistance = getPinchDistance(e.touches);
        const scale = currentDistance / initialPinchDistance;
        // Increase sensitivity with a nonlinear scale.
        currentTrailingDistance = initialTrailingDistance * Math.pow(scale, 1.5);
        currentTrailingDistance = Math.min(Math.max(currentTrailingDistance, 60), 200);
      }
    }, { passive: false });
    document.addEventListener("touchend", function (e) {
      if (e.touches.length < 2) {
        isPinching = false;
      }
    }, { passive: false });

    // Main animation loop.
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (plane) {
        forwardSpeed = parseFloat(throttle.value);
        const desiredPitch = THREE.MathUtils.degToRad(deviceBeta);
        const desiredRoll = THREE.MathUtils.degToRad(deviceGamma);
        plane.rotation.x = THREE.MathUtils.lerp(plane.rotation.x, desiredPitch, 0.1);
        plane.rotation.z = THREE.MathUtils.lerp(plane.rotation.z, -desiredRoll, 0.1);
        plane.rotation.y -= desiredRoll * delta * 0.5;
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(plane.quaternion);
        plane.position.add(forward.multiplyScalar(forwardSpeed * delta));
      }
      updateCamera(delta);
      renderer.render(scene, camera);
    }

    init();
    checkOrientation(); // Check orientation on load.
    animate();
  </script>
</body>
</html>
