<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Prevent zooming and disable user scaling/touch callouts -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Flight Simulator – Full Experience</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #87CEEB;  /* Sky-blue background */
      font-family: sans-serif;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    /* Prevent text selection */
    body {
      -moz-user-select: none;
      -khtml-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
    }
    /* HUD (altimeter & speedometer) in the top left */
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 30;
      font-size: 14px;
    }
    /* Throttle slider container (bottom-right) */
    #throttleContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255,255,255,0.8);
      padding: 10px;
      border-radius: 8px;
      z-index: 20;
    }
    /* Rotate the throttle slider so it runs vertically */
    #throttleContainer input[type="range"] {
      -webkit-appearance: none;
      width: 150px;
      transform: rotate(270deg);
    }
    /* Virtual joystick container (bigger and centered horizontally) */
    #joystick-container {
      position: fixed;
      bottom: 20px;
      left: calc(50% - 75px);  /* container is 150px wide */
      width: 150px;
      height: 150px;
      background: rgba(0,0,0,0.2);
      border: 2px solid rgba(0,0,0,0.5);
      border-radius: 50%;
      z-index: 20;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #joystick {
      width: 70px;
      height: 70px;
      background: rgba(0,0,0,0.5);
      border-radius: 50%;
      position: relative;
      touch-action: none;
    }
    /* Start screen overlay */
    #startScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      color: #fff;
      z-index: 100;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
    }
    #startScreen button {
      padding: 10px 20px;
      font-size: 18px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
  <!-- Import map for Three.js modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>
</head>
<body oncopy="return false;" onpaste="return false;" oncut="return false;">
  <!-- Start Screen Overlay -->
  <div id="startScreen">
    <h1>Flight Simulator</h1>
    <p>Use the joystick (center of the screen) to steer and the throttle (bottom–right) to control engine speed.</p>
    <p><span style="font-size: 48px;">↓</span><br>Drag the joystick to turn</p>
    <button id="startButton">Start Game</button>
  </div>

  <!-- HUD for altitude and speed -->
  <div id="hud">
    <div id="altimeter">Altitude: 0 m</div>
    <div id="speedometer">Speed: 0 km/h</div>
  </div>
  <!-- Throttle UI (vertical slider on the right) -->
  <div id="throttleContainer">
    <label for="throttle">Throttle</label>
    <input type="range" id="throttle" min="0" max="5" step="0.1" value="0">
  </div>
  <!-- Virtual Joystick (centered and enlarged) -->
  <div id="joystick-container">
    <div id="joystick"></div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    // Prevent copy/cut/paste events.
    document.addEventListener('copy', e => e.preventDefault());
    document.addEventListener('cut', e => e.preventDefault());
    document.addEventListener('paste', e => e.preventDefault());

    // Global variables.
    let scene, camera, renderer, plane, clock;
    let throttleSlider, joystickContainer, joystickElem;
    const hudAltimeter = document.getElementById("altimeter");
    const hudSpeedometer = document.getElementById("speedometer");
    const joystick = { x: 0, y: 0 };
    let cameraYawOffset = 0, isDraggingCamera = false, dragStartX = 0;
    let prevPlanePosition = new THREE.Vector3();

    // Array for obstacles (runways, buildings, etc.).
    const obstacles = [];

    // Target sizes for the plane (in meters).
    const targetPlaneLength = 8;   // desired length ~8 m.
    const targetPlaneHeight = 3;   // desired height ~3 m.
    // Camera trailing parameters.
    let trailingDistance = targetPlaneLength * 3;  // ~24 m behind.
    let verticalOffset = targetPlaneHeight * 1.5;    // ~4.5 m above.

    // Physics factors (reverted to original crisp handling, but with a slightly tighter roll response).
    const speedFactor = 30;      // throttle sensitivity.
    const gravity = 9.8;         // gravity.
    const pitchFactor = 0.8;
    const yawFactor = 0.5;
    const maxBankAngle = THREE.MathUtils.degToRad(30);
    const rollLerpFactor = 0.2;  // increased from 0.1 for tighter roll snap-back.

    // Fog settings (linear fog for distant visibility).
    const fogColor = 0x87CEEB;
    const fogNear = 2000;
    const fogFar = 3000;

    // Function to initialize the game scene and objects.
    function init() {
      // Create scene.
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);

      // Set up camera.
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

      // Renderer.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Lighting.
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 100);
      scene.add(directionalLight);

      // Create large grass ground.
      const groundGeo = new THREE.PlaneGeometry(10000, 10000);
      const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // Create Runways.
      // Main runway: always at (0, 1.2, 0) so the plane spawns on it.
      createRunway(new THREE.Vector3(0, 1.2, 0));
      // Additional runways.
      createRunway(new THREE.Vector3(200, 1.2, -600));
      createRunway(new THREE.Vector3(-200, 1.2, -600));

      // Spawn additional structures.
      spawnVillages(5);
      spawnCity(15);        // City clusters.
      spawnDetailedCity();  // A big, detailed city.

      // Spawn an infinite landscape.
      spawnInfiniteLandscape();

      // Spawn regular clouds (for lower altitudes).
      spawnClouds();

      // Get UI elements.
      throttleSlider = document.getElementById("throttle");
      throttleSlider.value = 0;
      joystickContainer = document.getElementById("joystick-container");
      joystickElem = document.getElementById("joystick");

      // Load the plane model.
      const loader = new GLTFLoader();
      loader.load(
        "models/plane.glb",
        (gltf) => {
          plane = gltf.scene;
          // Always spawn the plane on the main runway at a fixed position.
          plane.position.set(0, 1.2, -10);
          plane.rotation.set(0, 0, 0); // Assume nose faces -Z.
          scene.add(plane);

          // Adjust plane scale based on target size.
          const box = new THREE.Box3().setFromObject(plane);
          const size = new THREE.Vector3();
          box.getSize(size);
          const currentLength = size.z;
          const scaleFactor = targetPlaneLength / currentLength;
          plane.scale.multiplyScalar(scaleFactor);

          // Recalculate trailing parameters.
          const newBox = new THREE.Box3().setFromObject(plane);
          const newSize = new THREE.Vector3();
          newBox.getSize(newSize);
          trailingDistance = newSize.z * 3;
          verticalOffset = newSize.y * 1.5;

          updateCamera(0);
        },
        undefined,
        (error) => {
          console.error("Error loading plane model:", error);
        }
      );

      clock = new THREE.Clock();
      window.addEventListener("resize", onWindowResize);

      // Set up camera drag events.
      renderer.domElement.addEventListener("pointerdown", onCameraDragStart);
      renderer.domElement.addEventListener("pointermove", onCameraDragMove);
      renderer.domElement.addEventListener("pointerup", onCameraDragEnd);
      renderer.domElement.addEventListener("pointercancel", onCameraDragEnd);

      // Set up joystick pointer events.
      joystickContainer.addEventListener("pointerdown", onJoystickStart);
      joystickContainer.addEventListener("pointermove", onJoystickMove);
      joystickContainer.addEventListener("pointerup", onJoystickEnd);
      joystickContainer.addEventListener("pointercancel", onJoystickEnd);
    }

    // Creates a runway with a black surface and dashed yellow centerline.
    function createRunway(position) {
      const runwayWidth = targetPlaneLength * 2.5;  // ~20 m wide.
      const runwayLength = targetPlaneLength * 25;    // ~200 m long.
      const runwayGeo = new THREE.PlaneGeometry(runwayWidth, runwayLength);
      // Translate geometry so the back edge aligns at z = 0.
      runwayGeo.translate(0, 0, -runwayLength / 2);
      // Create a canvas texture for the runway.
      const runwayCanvas = document.createElement("canvas");
      runwayCanvas.width = 64;
      runwayCanvas.height = 256;
      const ctx = runwayCanvas.getContext("2d");
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, runwayCanvas.width, runwayCanvas.height);
      ctx.fillStyle = "#FFFF00";
      for (let y = 0; y < runwayCanvas.height; y += 20) {
        ctx.fillRect(runwayCanvas.width / 2 - 2, y, 4, 5);
      }
      const runwayTexture = new THREE.CanvasTexture(runwayCanvas);
      // Fix texture flickering at a distance.
      runwayTexture.minFilter = THREE.LinearFilter;
      runwayTexture.wrapS = THREE.RepeatWrapping;
      runwayTexture.wrapT = THREE.RepeatWrapping;
      runwayTexture.repeat.set(1, runwayLength / 64);
      const runwayMat = new THREE.MeshPhongMaterial({ map: runwayTexture });
      const runwayMesh = new THREE.Mesh(runwayGeo, runwayMat);
      runwayMesh.rotation.x = -Math.PI / 2;
      runwayMesh.position.copy(position);
      scene.add(runwayMesh);
      // Mark runway as an impermeable obstacle.
      runwayMesh.userData.boundingBox = new THREE.Box3().setFromObject(runwayMesh);
      obstacles.push(runwayMesh);
      return runwayMesh;
    }

    // Spawns clusters ("villages") of houses.
    function spawnVillages(numPatches) {
      for (let i = 0; i < numPatches; i++) {
        let centerX = THREE.MathUtils.randFloatSpread(300);
        let centerZ = THREE.MathUtils.randFloat(-400, -100);
        let count = Math.floor(THREE.MathUtils.randFloat(5, 10));
        for (let j = 0; j < count; j++) {
          let offsetX = THREE.MathUtils.randFloat(-20, 20);
          let offsetZ = THREE.MathUtils.randFloat(-20, 20);
          let scaleFactor = THREE.MathUtils.randFloat(0.5, 1.0);
          createHouse(centerX + offsetX, centerZ + offsetZ, scaleFactor);
        }
      }
    }

    // Spawns a city cluster (less detailed).
    function spawnCity(count) {
      let cityCenterX = THREE.MathUtils.randFloat(-50, 50);
      let cityCenterZ = -800;
      for (let i = 0; i < count; i++) {
        let offsetX = THREE.MathUtils.randFloat(-100, 100);
        let offsetZ = THREE.MathUtils.randFloat(-50, 50);
        createSkyscraper(cityCenterX + offsetX, cityCenterZ + offsetZ);
      }
    }

    // Spawns a detailed city with many buildings and streets.
    function spawnDetailedCity() {
      for (let i = 0; i < 50; i++) {
        let x = THREE.MathUtils.randFloat(-150, 150);
        let z = THREE.MathUtils.randFloat(-1000, -600);
        createSkyscraper(x, z, true);
      }
      for (let i = 0; i < 5; i++) {
        let x = THREE.MathUtils.randFloat(-150, 150);
        let z = THREE.MathUtils.randFloat(-1000, -600);
        createStreet(x, z, 200, 10, Math.random() > 0.5 ? 0 : Math.PI / 2);
      }
    }

    // Spawns trees, extra buildings, and streets over a large area.
    function spawnInfiniteLandscape() {
      // Spawn many trees over a wide area.
      for (let i = 0; i < 800; i++) {
        let x, z;
        do {
          x = THREE.MathUtils.randFloatSpread(4000);
          z = THREE.MathUtils.randFloat(-4000, 4000);
        } while (isOnRunway(x, z));
        createTree(x, z);
      }
      // Spawn extra generic buildings.
      for (let i = 0; i < 500; i++) {
        let x = THREE.MathUtils.randFloatSpread(4000);
        let z = THREE.MathUtils.randFloat(-4000, 4000);
        createGenericBuilding(x, z);
      }
      // Spawn extra streets.
      for (let i = 0; i < 20; i++) {
        let x = THREE.MathUtils.randFloatSpread(4000);
        let z = THREE.MathUtils.randFloat(-4000, 4000);
        createStreet(x, z, 150, 8, Math.random() > 0.5 ? 0 : Math.PI / 2);
      }
    }

    // Helper to decide if a coordinate falls on the main runway.
    function isOnRunway(x, z) {
      if (x > -15 && x < 15 && z < 10 && z > -210) return true;
      return false;
    }

    // Create a simple house (box body with cone roof).
    function createHouse(x, z, scaleFactor = 1) {
      const houseGroup = new THREE.Group();
      const bodyGeo = new THREE.BoxGeometry(10, 8, 10);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
      bodyMesh.position.y = 4;
      houseGroup.add(bodyMesh);
      const roofGeo = new THREE.ConeGeometry(6, 4, 4);
      const roofMat = new THREE.MeshPhongMaterial({ color: 0x808080 });
      const roofMesh = new THREE.Mesh(roofGeo, roofMat);
      roofMesh.position.y = 10;
      roofMesh.rotation.y = Math.PI / 4;
      houseGroup.add(roofMesh);
      houseGroup.position.set(x, 0, z);
      houseGroup.scale.set(scaleFactor, scaleFactor, scaleFactor);
      scene.add(houseGroup);
      houseGroup.userData.boundingBox = new THREE.Box3().setFromObject(houseGroup);
      obstacles.push(houseGroup);
    }

    // Create a skyscraper as a tall box.
    function createSkyscraper(x, z, detailed = false) {
      const height = THREE.MathUtils.randFloat(30, detailed ? 100 : 60);
      const geo = new THREE.BoxGeometry(20, height, 20);
      const mat = new THREE.MeshPhongMaterial({ color: detailed ? 0x666666 : 0x999999 });
      const building = new THREE.Mesh(geo, mat);
      building.position.y = height / 2;
      building.position.set(x, 0, z);
      scene.add(building);
      building.userData.boundingBox = new THREE.Box3().setFromObject(building);
      obstacles.push(building);
    }

    // Create a generic building with a random design.
    function createGenericBuilding(x, z) {
      const width = THREE.MathUtils.randFloat(10, 30);
      const depth = THREE.MathUtils.randFloat(10, 30);
      const height = THREE.MathUtils.randFloat(20, 80);
      const geo = new THREE.BoxGeometry(width, height, depth);
      const mat = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
      const building = new THREE.Mesh(geo, mat);
      building.position.y = height / 2;
      building.position.set(x, 0, z);
      scene.add(building);
      building.userData.boundingBox = new THREE.Box3().setFromObject(building);
      obstacles.push(building);
    }

    // Create a tree with varied trunk and crown.
    function createTree(x, z) {
      const treeGroup = new THREE.Group();
      const trunkHeight = THREE.MathUtils.randFloat(1.5, 3);
      const trunkRadius = THREE.MathUtils.randFloat(0.2, 0.5);
      const trunkGeo = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 8);
      const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = trunkHeight / 2;
      treeGroup.add(trunk);
      const crownRadius = THREE.MathUtils.randFloat(1, 2);
      const crownGeo = new THREE.SphereGeometry(crownRadius, 8, 8);
      const crownMat = new THREE.MeshPhongMaterial({ color: 0x2E8B57 });
      const crown = new THREE.Mesh(crownGeo, crownMat);
      crown.position.y = trunkHeight + crownRadius * 0.8;
      treeGroup.add(crown);
      treeGroup.position.set(x, 0, z);
      scene.add(treeGroup);
    }

    // Create a street as a long black plane with dashed white center.
    function createStreet(x, z, length, width, orientation = 0) {
      const streetGeo = new THREE.PlaneGeometry(width, length);
      const streetCanvas = document.createElement("canvas");
      streetCanvas.width = 64;
      streetCanvas.height = 256;
      const ctx = streetCanvas.getContext("2d");
      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, streetCanvas.width, streetCanvas.height);
      ctx.fillStyle = "#FFFFFF";
      for (let y = 0; y < streetCanvas.height; y += 40) {
        ctx.fillRect(streetCanvas.width / 2 - 2, y, 4, 15);
      }
      const streetTexture = new THREE.CanvasTexture(streetCanvas);
      streetTexture.wrapS = THREE.RepeatWrapping;
      streetTexture.wrapT = THREE.RepeatWrapping;
      streetTexture.repeat.set(1, length / 64);
      const streetMat = new THREE.MeshPhongMaterial({ map: streetTexture });
      const streetMesh = new THREE.Mesh(streetGeo, streetMat);
      streetMesh.rotation.x = -Math.PI / 2;
      streetMesh.rotation.z = orientation;
      streetMesh.position.set(x, 0.1, z);
      scene.add(streetMesh);
      streetMesh.userData.boundingBox = new THREE.Box3().setFromObject(streetMesh);
      obstacles.push(streetMesh);
    }

    // Spawn regular clouds (for lower altitudes). Increase number for realism.
    function spawnClouds() {
      for (let i = 0; i < 80; i++) {
        const cloud = createCloud(THREE.MathUtils.randFloat(300, 1000));
        scene.add(cloud);
      }
    }

    // Spawn high clouds (for altitudes around 6000 m).
    function spawnHighClouds() {
      for (let i = 0; i < 80; i++) {
        const cloud = createCloud(THREE.MathUtils.randFloat(6000, 6100));
        scene.add(cloud);
      }
    }

    // Create a cloud (a group of overlapping spheres).
    // The yPos parameter sets the vertical level of the cloud.
    function createCloud(yPos) {
      const cloudGroup = new THREE.Group();
      const material = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
      const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(10, 8, 8), material);
      cloudGroup.add(sphere1);
      const sphere2 = new THREE.Mesh(new THREE.SphereGeometry(7, 8, 8), material);
      sphere2.position.set(10, 0, 0);
      cloudGroup.add(sphere2);
      const sphere3 = new THREE.Mesh(new THREE.SphereGeometry(6, 8, 8), material);
      sphere3.position.set(-8, 2, 0);
      cloudGroup.add(sphere3);
      cloudGroup.position.set(
        THREE.MathUtils.randFloatSpread(2000),
        yPos,
        THREE.MathUtils.randFloatSpread(2000)
      );
      return cloudGroup;
    }

    // Update viewport on window resize.
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Camera drag events ---
    function onCameraDragStart(event) {
      if (event.target.closest("#joystick-container") || event.target.closest("#throttleContainer") || event.target.closest("#hud") || event.target.closest("#startScreen"))
        return;
      isDraggingCamera = true;
      dragStartX = event.clientX;
    }
    function onCameraDragMove(event) {
      if (!isDraggingCamera) return;
      const dx = event.clientX - dragStartX;
      cameraYawOffset += dx * 0.005;
      dragStartX = event.clientX;
    }
    function onCameraDragEnd(event) {
      isDraggingCamera = false;
    }

    // --- Joystick pointer events ---
    let joystickActive = false;
    let joystickCenter = { x: 0, y: 0 };
    function onJoystickStart(event) {
      joystickActive = true;
      const rect = joystickContainer.getBoundingClientRect();
      joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      updateJoystick(event);
    }
    function onJoystickMove(event) {
      if (!joystickActive) return;
      updateJoystick(event);
    }
    function onJoystickEnd(event) {
      joystickActive = false;
      joystick.x = 0;
      joystick.y = 0;
      joystickElem.style.transform = `translate(0px, 0px)`;
    }
    function updateJoystick(event) {
      let clientX, clientY;
      if (event.changedTouches && event.changedTouches.length > 0) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
      } else {
        clientX = event.clientX;
        clientY = event.clientY;
      }
      const dx = clientX - joystickCenter.x;
      const dy = clientY - joystickCenter.y;
      const maxDist = joystickContainer.clientWidth / 2;
      joystick.x = Math.max(-1, Math.min(1, dx / maxDist));
      joystick.y = Math.max(-1, Math.min(1, dy / maxDist));
      const thumbMax = maxDist - (joystickElem.clientWidth / 2);
      const moveX = Math.max(-thumbMax, Math.min(thumbMax, dx));
      const moveY = Math.max(-thumbMax, Math.min(thumbMax, dy));
      joystickElem.style.transform = `translate(${moveX}px, ${moveY}px)`;
    }

    // --- Update camera to follow the plane ---
    function updateCamera(delta) {
      if (!plane) return;
      let planeDir = new THREE.Vector3();
      plane.getWorldDirection(planeDir);
      planeDir.y = 0;
      planeDir.normalize();
      const tailVector = planeDir.clone().multiplyScalar(trailingDistance);
      if (cameraYawOffset !== 0) {
        tailVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYawOffset);
      }
      const desiredPos = new THREE.Vector3().copy(plane.position)
                              .add(new THREE.Vector3(0, verticalOffset, 0))
                              .add(tailVector);
      camera.position.lerp(desiredPos, 0.1);
      const lookAtPoint = new THREE.Vector3().copy(plane.position)
                              .add(new THREE.Vector3(0, verticalOffset, 0));
      camera.lookAt(lookAtPoint);
    }

    // Simple collision detection: if the plane intersects an obstacle, revert its position and set throttle to 0.
    function checkCollisions() {
      if (!plane) return;
      const planeBox = new THREE.Box3().setFromObject(plane);
      for (let i = 0; i < obstacles.length; i++) {
        if (obstacles[i].userData.boundingBox && planeBox.intersectsBox(obstacles[i].userData.boundingBox)) {
          plane.position.copy(prevPlanePosition);
          throttleSlider.value = 0;
          break;
        }
      }
    }

    // Main animation loop.
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (plane) {
        // --- Joystick steering (original handling with slightly faster roll snap-back) ---
        const currentEuler = new THREE.Euler().setFromQuaternion(plane.quaternion, "YXZ");
        currentEuler.x += joystick.y * pitchFactor * delta;
        currentEuler.y -= joystick.x * yawFactor * delta;
        const targetRoll = -joystick.x * maxBankAngle;
        currentEuler.z = THREE.MathUtils.lerp(currentEuler.z, targetRoll, rollLerpFactor);
        plane.quaternion.setFromEuler(currentEuler);

        // --- Physics integration (original simple motion) ---
        prevPlanePosition.copy(plane.position);
        const throttleValue = parseFloat(throttleSlider.value);
        const forwardVec = new THREE.Vector3(0, 0, -1).applyQuaternion(plane.quaternion).normalize();
        plane.position.add(forwardVec.multiplyScalar(throttleValue * speedFactor * delta));
        if (throttleValue < 1) {
          plane.position.y -= gravity * (1 - throttleValue) * delta;
        }
        if (plane.position.y < 1.2) {
          plane.position.y = 1.2;
        }

        // Update HUD.
        const speedKmh = throttleValue * speedFactor * 3.6;
        hudAltimeter.innerHTML = `Altitude: ${plane.position.y.toFixed(1)} m`;
        hudSpeedometer.innerHTML = `Speed: ${speedKmh.toFixed(1)} km/h`;

        // Check collisions.
        checkCollisions();

        // If the plane climbs above 6000 m, spawn high clouds (if not already).
        if (plane.position.y > 6000) {
          spawnHighClouds();
        }
      }

      updateCamera(delta);
      renderer.render(scene, camera);
    }

    // --- Start Game: Remove the overlay and initialize the game.
    function startGame() {
      const startScreen = document.getElementById("startScreen");
      startScreen.style.display = "none";
      init();
      animate();
    }

    // Set up the start button event.
    const startButton = document.getElementById("startButton");
    startButton.addEventListener("click", startGame);
  </script>
</body>
</html>
