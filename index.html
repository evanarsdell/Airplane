<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Mobile Responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Enhanced Mobile 2.5D Flight Simulator</title>
  <style>
    /* Reset defaults */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }
    /* Full-screen canvas */
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }
    /* Overlay message in portrait mode */
    @media only screen and (orientation: portrait) {
      body::before {
        content: "Please rotate your device to landscape mode for best experience";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-size: 1.5em;
        z-index: 1000;
      }
    }
    /* Throttle UI styling */
    #throttleControl {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      border: 2px solid #333;
      text-align: center;
      line-height: 80px;
      font-weight: bold;
      user-select: none;
      z-index: 20;
      touch-action: none;
    }
    /* HUD styling */
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 20;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Canvas for the game rendering -->
  <canvas id="gameCanvas"></canvas>
  <!-- Throttle control UI -->
  <div id="throttleControl">0%</div>
  <!-- On-screen HUD -->
  <div id="hud">Speed: 0<br>Altitude: 0<br>Throttle: 0%</div>

  <script>
    "use strict";

    /**********************************
     * Utility Functions
     **********************************/
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    /**********************************
     * InputHandler Module
     * - Reads DeviceOrientation for pitch and roll.
     * - Processes touch events on the throttle control.
     **********************************/
    class InputHandler {
      constructor(throttleElement) {
        this.pitch = 0; // Degrees: positive = nose down, negative = nose up
        this.roll = 0;  // Degrees: positive = tilt right, negative = tilt left
        this.deadZone = 3; // Ignore small movements to reduce jitter
        this.throttle = 0; // 0 to 100%
        this.throttleElement = throttleElement;
        this.initOrientation();
        this.initThrottle();
      }
      
      // Listen for device orientation events
      initOrientation() {
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', (event) => {
            // event.beta: pitch; event.gamma: roll
            let rawPitch = event.beta || 0;
            let rawRoll = event.gamma || 0;
            this.pitch = (Math.abs(rawPitch) > this.deadZone) ? rawPitch : 0;
            this.roll = (Math.abs(rawRoll) > this.deadZone) ? rawRoll : 0;
          }, true);
        } else {
          console.warn("DeviceOrientationEvent is not supported by your browser.");
        }
      }
      
      // Set up touch events for throttle control
      initThrottle() {
        let startY = 0;
        let initialThrottle = this.throttle;
        const onTouchStart = (e) => {
          e.preventDefault();
          startY = e.touches[0].clientY;
          initialThrottle = this.throttle;
        };
        const onTouchMove = (e) => {
          e.preventDefault();
          let currentY = e.touches[0].clientY;
          let delta = startY - currentY; // Up swipe increases throttle
          const sensitivity = 0.2; // Adjust how fast throttle changes
          this.throttle = clamp(initialThrottle + delta * sensitivity, 0, 100);
          this.updateThrottleUI();
        };
        this.throttleElement.addEventListener("touchstart", onTouchStart, false);
        this.throttleElement.addEventListener("touchmove", onTouchMove, false);
        // Allow mouse click for desktop testing
        this.throttleElement.addEventListener("click", () => {
          this.throttle = (this.throttle + 10) % 110;
          this.updateThrottleUI();
        });
      }
      
      updateThrottleUI() {
        this.throttleElement.innerText = Math.round(this.throttle) + "%";
      }
    }

    /**********************************
     * PhysicsEngine Module
     * - Simulates flight dynamics (forward motion, altitude, lift, drag, gravity).
     * - Updates aircraft state based on throttle and orientation input.
     **********************************/
    class PhysicsEngine {
      constructor() {
        // Position: x = forward distance, y = altitude (start high so you can descend)
        this.position = { x: 0, y: 100 };
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        // Physics constants
        this.gravity = 0.3;      // Constant downward acceleration
        this.liftFactor = 0.1;   // Lift produced per degree of pitch (adjust sign as needed)
        this.dragFactor = 0.005; // Simulated drag factor
        this.enginePower = 0.5;  // Thrust multiplier based on throttle input
      }
      
      update(deltaTime, input) {
        // Forward thrust: throttle force minus drag
        let throttleForce = input.throttle * this.enginePower * 0.01;
        this.acceleration.x = throttleForce - (this.dragFactor * this.velocity.x);
        
        // Vertical acceleration: lift (negative pitch gives upward force) minus gravity and drag
        // Note: A positive pitch (nose down) reduces lift.
        let lift = -input.pitch * this.liftFactor;
        this.acceleration.y = lift - this.gravity - (this.dragFactor * this.velocity.y);
        
        // Update velocity and position (Euler integration)
        this.velocity.x += this.acceleration.x * deltaTime;
        this.velocity.y += this.acceleration.y * deltaTime;
        this.position.x += this.velocity.x * deltaTime;
        this.position.y += this.velocity.y * deltaTime;
        
        // Prevent aircraft from going below ground level (altitude 0)
        if (this.position.y < 0) {
          this.position.y = 0;
          this.velocity.y = 0;
        }
      }
    }

    /**********************************
     * Renderer Module
     * - Renders the 2.5D environment using canvas.
     * - Applies a camera transformation based on the aircraft's pitch and slight roll.
     **********************************/
    class Renderer {
      constructor(canvas, physics) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.physics = physics;
        this.structures = this.generateStructures(20);
        this.resize();
        window.addEventListener("resize", () => this.resize());
      }
      
      // Adjust canvas to fit the window
      resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
      
      // Create random environmental structures for parallax effect
      generateStructures(count) {
        const types = ["rect", "circle", "triangle"];
        const colors = ["#8B4513", "#A0522D", "#556B2F"];
        let structures = [];
        for (let i = 0; i < count; i++) {
          structures.push({
            x: Math.random() * window.innerWidth,
            // y here represents distance from the camera (0 = near, higher = further away)
            y: 50 + Math.random() * 300,
            size: 20 + Math.random() * 30,
            type: types[Math.floor(Math.random() * types.length)],
            color: colors[Math.floor(Math.random() * colors.length)]
          });
        }
        return structures;
      }
      
      // Render the entire scene
      render(input) {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;
        
        // Clear the canvas
        ctx.clearRect(0, 0, w, h);
        
        // Save current state and apply a camera transformation
        ctx.save();
        // Shift the horizon based on pitch (nosedown shifts horizon downwards)
        const pitchOffset = input.pitch * 2;
        // Apply a subtle roll rotation to the entire scene (for immersive effect)
        const rollAngle = input.roll * Math.PI / 180 * 0.2;
        ctx.translate(0, pitchOffset);
        ctx.rotate(rollAngle);
        
        // Draw sky and ground
        this.drawBackground();
        // Draw runway with perspective (horizon moves based on pitch)
        this.drawRunway(input);
        // Draw environmental structures with parallax scaling
        this.drawStructures();
        // Restore transformation for fixed HUD elements (aircraft will be drawn on top)
        ctx.restore();
        
        // Draw the aircraft (using a fixed cockpit view)
        this.drawAircraft(input);
      }
      
      // Draw sky and ground
      drawBackground() {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        // Sky
        let skyGradient = ctx.createLinearGradient(0, 0, 0, h);
        skyGradient.addColorStop(0, "#87CEEB");
        skyGradient.addColorStop(1, "#87CEEB");
        ctx.fillStyle = skyGradient;
        ctx.fillRect(0, 0, w, h);
        // Ground
        let groundGradient = ctx.createLinearGradient(0, h * 0.6, 0, h);
        groundGradient.addColorStop(0, "#228B22");
        groundGradient.addColorStop(1, "#006400");
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, h * 0.6, w, h * 0.4);
      }
      
      // Draw a perspective runway that adjusts based on pitch input
      drawRunway(input) {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        ctx.save();
        // Adjust horizon position with pitch: a higher nose-up (negative pitch) raises the horizon.
        const horizonY = h * 0.6 + input.pitch * 2;
        const centerX = w / 2;
        // Define the trapezoid for the runway
        const topWidth = w * 0.1;
        const bottomWidth = w * 0.8;
        ctx.beginPath();
        ctx.moveTo(centerX - topWidth / 2, horizonY);
        ctx.lineTo(centerX + topWidth / 2, horizonY);
        ctx.lineTo(centerX + bottomWidth / 2, h);
        ctx.lineTo(centerX - bottomWidth / 2, h);
        ctx.closePath();
        ctx.fillStyle = "#333";
        ctx.fill();
        // Draw center markings for the runway
        ctx.strokeStyle = "#FFF";
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 20]);
        ctx.beginPath();
        ctx.moveTo(centerX, horizonY);
        ctx.lineTo(centerX, h);
        ctx.stroke();
        ctx.restore();
      }
      
      // Draw environmental structures with a parallax effect
      drawStructures() {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        this.structures.forEach((struct) => {
          // Simulate movement: objects closer to the horizon (lower y) appear larger
          let relativeY = struct.y - (this.physics.position.x * 0.05) % 300;
          if (relativeY < 0) relativeY += 300;
          let scale = 1 + (300 - relativeY) / 600;
          // Adjust positions using the scale factor
          let posX = struct.x * scale;
          let posY = h * 0.6 + relativeY;
          ctx.save();
          ctx.translate(posX, posY);
          ctx.scale(scale, scale);
          ctx.fillStyle = struct.color;
          switch(struct.type) {
            case "rect":
              ctx.fillRect(-struct.size/2, -struct.size/2, struct.size, struct.size);
              break;
            case "circle":
              ctx.beginPath();
              ctx.arc(0, 0, struct.size/2, 0, Math.PI * 2);
              ctx.fill();
              break;
            case "triangle":
              ctx.beginPath();
              ctx.moveTo(0, -struct.size/2);
              ctx.lineTo(-struct.size/2, struct.size/2);
              ctx.lineTo(struct.size/2, struct.size/2);
              ctx.closePath();
              ctx.fill();
              break;
          }
          ctx.restore();
        });
      }
      
      // Draw the aircraft in a fixed cockpit view
      drawAircraft(input) {
        const ctx = this.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        ctx.save();
        // Position the aircraft in the lower center of the screen
        ctx.translate(w / 2, h * 0.75);
        // Apply the roll rotation to simulate banking
        ctx.rotate(input.roll * Math.PI / 180);
        // Optionally, you can adjust vertical position with pitch (e.g., a slight shift)
        // ctx.translate(0, input.pitch * 0.5);
        // Draw a simple triangle representing the aircraft
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(-10, 15);
        ctx.lineTo(10, 15);
        ctx.closePath();
        ctx.fillStyle = "#FF0";
        ctx.fill();
        ctx.restore();
      }
    }

    /**********************************
     * UIController Module
     * - Updates the HUD display with real-time flight data.
     **********************************/
    class UIController {
      constructor(hudElement) {
        this.hudElement = hudElement;
      }
      update(speed, altitude, throttle) {
        this.hudElement.innerHTML = 
          "Speed: " + speed.toFixed(1) + "<br>" +
          "Altitude: " + altitude.toFixed(1) + "<br>" +
          "Throttle: " + Math.round(throttle) + "%";
      }
    }

    /**********************************
     * GameEngine Module
     * - Manages the main game loop, state transitions, and inter-module communication.
     **********************************/
    class GameEngine {
      constructor() {
        this.canvas = document.getElementById("gameCanvas");
        this.inputHandler = new InputHandler(document.getElementById("throttleControl"));
        this.physicsEngine = new PhysicsEngine();
        this.renderer = new Renderer(this.canvas, this.physicsEngine);
        this.uiController = new UIController(document.getElementById("hud"));
        this.state = "active"; // active, game_over
        this.lastTime = performance.now();
        this.gameLoop = this.gameLoop.bind(this);
        // Listen for a tap to restart after a game over
        this.canvas.addEventListener("click", () => {
          if(this.state === "game_over") this.restartGame();
        });
      }
      
      gameLoop(currentTime) {
        let deltaTime = (currentTime - this.lastTime) / 16.67; // Normalize to ~60fps
        this.lastTime = currentTime;
        
        if (this.state === "active") {
          // Update physics based on user input
          this.physicsEngine.update(deltaTime, this.inputHandler);
          // If the aircraft touches the ground (altitude <= 0), trigger game over
          if (this.physicsEngine.position.y <= 0) {
            this.state = "game_over";
          }
        }
        
        // Render the scene using current input data
        this.renderer.render(this.inputHandler);
        // Update HUD (using absolute speed and altitude)
        this.uiController.update(
          Math.abs(this.physicsEngine.velocity.x),
          this.physicsEngine.position.y,
          this.inputHandler.throttle
        );
        
        if (this.state === "active") {
          requestAnimationFrame(this.gameLoop);
        } else {
          this.displayGameOver();
        }
      }
      
      // Display a game over overlay
      displayGameOver() {
        const ctx = this.renderer.ctx;
        const w = this.canvas.width, h = this.canvas.height;
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = "#FFF";
        ctx.font = "48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", w/2, h/2);
        ctx.font = "24px sans-serif";
        ctx.fillText("Tap to Restart", w/2, h/2 + 40);
        ctx.restore();
      }
      
      // Reset game state to restart the simulation
      restartGame() {
        this.physicsEngine = new PhysicsEngine();
        this.renderer.physics = this.physicsEngine;
        this.lastTime = performance.now();
        this.state = "active";
        requestAnimationFrame(this.gameLoop);
      }
      
      start() {
        this.lastTime = performance.now();
        requestAnimationFrame(this.gameLoop);
      }
    }

    /**********************************
     * Initialize and start the game
     **********************************/
    document.addEventListener("DOMContentLoaded", () => {
      const game = new GameEngine();
      game.start();
    });
  </script>
</body>
</html>
