<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Flight Simulator â€“ Revamped</title>
  <style>
    :root {
      --bg-sky: #87CEEB;
      --ground-green: #228B22;
      --ui-bg: rgba(0,0,0,0.7);
      --ui-color: #fff;
      --accent-red: #f33;
      --font-base: sans-serif;
      --hud-size: 14px;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    html, body {
      width:100%; height:100%;
      overflow:hidden;
      background: var(--bg-sky);
      font-family: var(--font-base);
      touch-action: none;
      user-select: none;
    }
    canvas { display:block; }

    /* Shared UI panels */
    .panel {
      position: fixed;
      background: var(--ui-bg);
      color: var(--ui-color);
      padding:0.5em 1em;
      border-radius:5px;
      font-size: var(--hud-size);
      z-index:20;
      user-select:none;
    }
    #hud        { top:1em; left:1em; }
    #timerPanel { top:1em; right:1em; text-align:center; }
    #highScore  { top:4em; right:1em; text-align:center; }
    #startScreen {
      top:0; left:0; width:100vw; height:100vh;
      background: rgba(0,0,0,0.85);
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      text-align:center; padding:2em; z-index:100;
    }
    #startScreen button {
      margin-top:1em; padding:0.5em 1em; font-size:1.2em;
      cursor:pointer;
    }

    /* Controls */
    #throttleContainer {
      position:fixed; bottom:1em; right:1em; z-index:20;
      transform: rotate(270deg);
    }
    #throttle {
      width:150px; -webkit-appearance:none; outline:none;
    }
    #throttle::-webkit-slider-runnable-track {
      height: 8px; background: #fff; border-radius:4px;
    }
    #throttle::-webkit-slider-thumb {
      width:20px; height:20px; background: var(--accent-red);
      border-radius:50%; margin-top:-6px; -webkit-appearance:none;
    }

    #joystick-container {
      position:fixed; bottom:1em; left:50%; transform:translateX(-50%);
      width:150px; height:150px; background: rgba(255,0,0,0.2);
      border:2px solid var(--accent-red); border-radius:50%;
      touch-action:none; z-index:20; display:flex;
      align-items:center; justify-content:center;
    }
    #joystick {
      width:60px; height:60px;
      background: rgba(255,0,0,0.6);
      border:2px solid var(--accent-red); border-radius:50%;
      touch-action:none; position:relative;
    }

    /* Landing message */
    #landingMsg {
      position:fixed; top:50%; left:50%;
      transform:translate(-50%,-50%);
      background:var(--ui-bg); color:yellow;
      padding:1em 2em; border-radius:8px;
      font-size:2em; text-align:center; z-index:50;
      display:none;
    }
  </style>

  <!-- Import map for Three.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "GLTFLoader": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
    }
  }
  </script>
</head>
<body>
  <!-- UI -->
  <div id="startScreen">
    <h1>Flight Simulator</h1>
    <p>Throttle on the right. Joystick to steer at bottom.</p>
    <button id="startBtn">Start</button>
  </div>
  <div id="hud" class="panel">
    <div id="altimeter">Alt: 0 m</div>
    <div id="speedo">Spd: 0 km/h</div>
  </div>
  <div id="timerPanel" class="panel">Time: 0.0 s</div>
  <div id="highScore" class="panel">Best: --</div>

  <div id="throttleContainer">
    <input type="range" id="throttle" min="0" max="5" step="0.1" value="0">
  </div>

  <div id="joystick-container">
    <div id="joystick"></div>
  </div>

  <div id="landingMsg"></div>

  <script type="module">
  import * as THREE from "three";
  import { GLTFLoader } from "GLTFLoader";

  class Game {
    constructor() {
      // Core three.js components
      this.scene   = new THREE.Scene();
      this.camera  = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000);
      this.renderer= new THREE.WebGLRenderer({ antialias:true });
      this.clock   = new THREE.Clock();

      // State
      this.plane        = null;
      this.obstacles    = [];
      this.treesInst    = null;
      this.flightStart  = 0;
      this.highScore    = parseFloat(localStorage.getItem("fsHighScore")) || Infinity;
      this.landingShown = false;

      // Bindings
      this.onResize      = this.debounce(this.onResize.bind(this), 200);
      this.animate       = this.animate.bind(this);
      this.handleLanding = this.handleLanding.bind(this);

      // UI
      this.ui = {
        alt: document.getElementById("altimeter"),
        spd: document.getElementById("speedo"),
        timer: document.getElementById("timerPanel"),
        best: document.getElementById("highScore"),
        landing: document.getElementById("landingMsg")
      };
      this.controls = {
        throttle: document.getElementById("throttle"),
        joystickContainer: document.getElementById("joystick-container"),
        joystickElem: document.getElementById("joystick")
      };
      this.joy = { x:0, y:0, active:false };
    }

    async start() {
      await this.loadAssets();
      this.setupRenderer();
      this.buildScene();
      this.setupControls();
      this.resetFlight();
      requestAnimationFrame(this.animate);
    }

    async loadAssets() {
      const loader = new GLTFLoader();
      const p = new Promise((res,rej)=>{
        loader.load("models/plane.glb", gltf => {
          this.plane = gltf.scene;
          res();
        }, undefined, rej);
      });
      return Promise.all([p]);
    }

    setupRenderer() {
      this.renderer.setSize(innerWidth, innerHeight);
      this.renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      this.renderer.physicallyCorrectLights = true;
      this.renderer.outputEncoding       = THREE.sRGBEncoding;
      document.body.appendChild(this.renderer.domElement);
      window.addEventListener("resize", this.onResize);
    }

    buildScene() {
      // Sky & Fog
      this.scene.background = new THREE.Color(0x87CEEB);
      this.scene.fog = new THREE.Fog(0x87CEEB, 1000, 2000);

      // Lights
      this.scene.add(new THREE.AmbientLight(0xffffff, 0.3));
      const dir = new THREE.DirectionalLight(0xffffff, 1.2);
      dir.position.set(-200,200,-200);
      this.scene.add(dir);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(10000,10000),
        new THREE.MeshStandardMaterial({ color: 0x228B22 })
      );
      ground.rotation.x = -Math.PI/2;
      this.scene.add(ground);

      // Home runway
      this.createRunway( new THREE.Vector3(0,1.2,-10), true );
      // Other runways
      this.createRunway( new THREE.Vector3(200,1.2,-1800) );
      this.createRunway( new THREE.Vector3(-200,1.2,-1800) );
      this.createRunway( new THREE.Vector3(0,1.2,-2500) );

      // Instanced trees
      this.spawnInstancedTrees( 800 );

      // Add plane after scaling
      this.plane.position.set(0,1.2,-10);
      const box = new THREE.Box3().setFromObject(this.plane);
      const size= new THREE.Vector3(); box.getSize(size);
      const scale= 8 / size.z;
      this.plane.scale.setScalar(scale);
      this.scene.add(this.plane);
    }

    createRunway(pos, isHome=false) {
      const length = 8 * 25, width = 8 * 2.5;
      // Simple gray rectangle
      const mat = new THREE.MeshStandardMaterial({ color:0x333 });
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(width, length),
        mat
      );
      mesh.rotation.x = -Math.PI/2;
      mesh.position.copy(pos);
      mesh.userData = { isHome };
      this.scene.add(mesh);
    }

    spawnInstancedTrees(count) {
      const geo = new THREE.ConeGeometry(1,2,8);
      const mat = new THREE.MeshStandardMaterial({ color:0x2E8B57 });
      const inst = new THREE.InstancedMesh(geo, mat, count);
      const dummy = new THREE.Object3D();
      for(let i=0;i<count;i++){
        const x = THREE.MathUtils.randFloatSpread(4000);
        const z = THREE.MathUtils.randFloat(-4000,4000);
        if ( Math.abs(z+10)<210 && Math.abs(x)<15 ) { i--; continue; }
        dummy.position.set(x,0,z);
        const s = THREE.MathUtils.randFloat(0.5,1.5);
        dummy.scale.set(s,s,s);
        dummy.updateMatrix();
        inst.setMatrixAt(i, dummy.matrix);
      }
      this.scene.add(inst);
      this.treesInst = inst;
    }

    setupControls() {
      // Throttle change
      this.controls.throttle.addEventListener("input", ()=>{});
      // Joystick
      this.controls.joystickContainer.addEventListener("pointerdown", e=>{
        this.controls.joystickContainer.setPointerCapture(e.pointerId);
        this.joy.active = true; this.updateJoystick(e);
      });
      this.controls.joystickContainer.addEventListener("pointermove", e=>{
        if(!this.joy.active) return;
        this.updateJoystick(e);
      });
      this.controls.joystickContainer.addEventListener("pointerup", e=>{
        this.controls.joystickContainer.releasePointerCapture(e.pointerId);
        this.joy.active = false; this.joy.x=0; this.joy.y=0;
        this.controls.joystickElem.style.transform = "";
      });
    }

    updateJoystick(e) {
      const rect = this.controls.joystickContainer.getBoundingClientRect();
      const cx = rect.left+rect.width/2, cy = rect.top+rect.height/2;
      const dx = e.clientX-cx, dy = e.clientY-cy;
      const max = rect.width/2;
      this.joy.x = THREE.MathUtils.clamp(dx/max, -1,1);
      this.joy.y = THREE.MathUtils.clamp(dy/max, -1,1);
      const moveX = THREE.MathUtils.clamp(dx, -max+30, max-30);
      const moveY = THREE.MathUtils.clamp(dy, -max+30, max-30);
      this.controls.joystickElem.style.transform = `translate(${moveX}px,${moveY}px)`;
    }

    resetFlight() {
      this.flightStart = performance.now();
      this.landingShown = false;
      if (this.highScore < Infinity) {
        this.ui.best.textContent = `Best: ${this.highScore.toFixed(1)} s`;
      }
    }

    animate() {
      requestAnimationFrame(this.animate);
      const dt = this.clock.getDelta();
      if (!this.plane) return;

      // Store prev pos
      const prevPos = this.plane.position.clone();

      // Rotation from joystick
      const e = new THREE.Euler().setFromQuaternion(this.plane.quaternion,"YXZ");
      e.x += this.joy.y * 0.8 * dt;
      e.y -= this.joy.x * 0.5 * dt;
      const targetRoll = -this.joy.x * THREE.MathUtils.degToRad(30);
      e.z = THREE.MathUtils.lerp(e.z, targetRoll, 0.2);
      this.plane.quaternion.setFromEuler(e);

      // Movement & gravity
      const throttle = parseFloat(this.controls.throttle.value);
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(this.plane.quaternion);
      this.plane.position.add(forward.multiplyScalar(throttle * 30 * dt));
      if (throttle < 1) {
        this.plane.position.y -= 9.8 * (1-throttle) * dt;
      }
      this.plane.position.y = Math.max(this.plane.position.y, 1.2);

      // UI updates (throttled by simple value checks)
      const alt = this.plane.position.y.toFixed(1),
            spd = (throttle * 30 * 3.6).toFixed(1),
            elapsed = ((performance.now()-this.flightStart)/1000).toFixed(1);
      if (this.lastAlt!==alt) { this.ui.alt.textContent=`Alt: ${alt} m`; this.lastAlt=alt; }
      if (this.lastSpd!==spd) { this.ui.spd.textContent=`Spd: ${spd} km/h`; this.lastSpd=spd; }
      this.ui.timer.textContent = `Time: ${elapsed} s`;

      // Simple ground collision rollback
      if (this.plane.position.distanceTo(prevPos) > 50) {
        this.plane.position.copy(prevPos);
      }

      // Landing detection (throttle=0, low altitude)
      if (throttle===0 && this.plane.position.y<1.4 && !this.landingShown) {
        this.handleLanding(elapsed);
      }

      // Camera follows
      const dir = new THREE.Vector3();
      this.plane.getWorldDirection(dir);
      const camPos = this.plane.position.clone()
                     .add(new THREE.Vector3(0,3,0))
                     .add(dir.multiplyScalar(-24));
      this.camera.position.lerp(camPos, 0.1);
      this.camera.lookAt(this.plane.position.clone().add(new THREE.Vector3(0,2,0)));

      this.renderer.render(this.scene, this.camera);
    }

    handleLanding(timeStr) {
      const t = parseFloat(timeStr);
      if (t < this.highScore) {
        this.highScore = t;
        localStorage.setItem("fsHighScore", t);
        this.ui.best.textContent = `Best: ${t.toFixed(1)} s`;
      }
      this.ui.landing.innerHTML = `<strong>Nice Landing!</strong><br>${timeStr} s`;
      this.ui.landing.style.display = "block";
      this.landingShown = true;
      setTimeout(()=>{
        this.ui.landing.style.display = "none";
        this.resetFlight();
      }, 3000);
    }

    onResize() {
      this.camera.aspect = innerWidth/innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(innerWidth, innerHeight);
    }

    // Simple debounce helper
    debounce(fn, ms) {
      let id;
      return (...args)=> {
        clearTimeout(id);
        id = setTimeout(()=> fn(...args), ms);
      };
    }
  }

  // Start button
  document.getElementById("startBtn").addEventListener("click", () => {
    document.getElementById("startScreen").style.display = "none";
    new Game().start();
  });

  </script>
</body>
</html>
