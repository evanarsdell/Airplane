<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple Flight Game</title>
  <style>
    /* Minimal CSS reset: fill viewport and use a sky-blue background */
    body {
      margin: 0;
      overflow: hidden;
      background: #87CEEB;
    }
    canvas {
      display: block;
    }
  </style>
  <!-- Three.js included from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<script>
/*
  Simple Flight Game – Basic Flight Controls

  Controls:
    • Throttle: Up Arrow (increase) and Down Arrow (decrease)
    • Pitch: W (nose down) and S (nose up)
    • Roll: A (tilt left) and D (tilt right)
    • Automatic yaw is applied proportional to the roll (simulate bank turn)
  
  Movement:
    • Horizontal movement is computed using the airplane’s yaw (rotation.y)
    • Vertical movement is updated by a simple physics model:
         vertical acceleration = (–pitch * pitchInfluence) + gravity
    • If the airplane’s altitude drops to ground level, it “lands.”
  
  Scene:
    • A huge grassy ground (infinite-feeling)
    • A long runway with a yellow dotted center line
    • Random blocky trees for scale
*/

// Global variables and constants
let scene, camera, renderer;
let airplane;
let airplaneSpeed = 0;
const airplaneMaxSpeed = 5;
const airplaneAcceleration = 0.02;
let verticalVelocity = 0;
const gravity = -0.0025;
const pitchInfluence = 0.05;
const groundLevel = 0.25;
const yawFactor = 0.02;       // automatic yaw change per frame per roll angle
const rollDamping = 0.98;     // damping when no roll input is given
const pitchDamping = 0.98;    // damping when no pitch input is given
const controlDelta = 0.01;    // change in rotation per frame per key press
const keys = {};              // tracks currently pressed keys

init();
animate();

function init() {
  // Create scene and set background (sky blue)
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);

  // Create camera with a far clipping plane for our huge world
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);

  // Set up renderer and add its canvas to the DOM
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Add lights: an ambient and a directional light
  scene.add(new THREE.AmbientLight(0x404040));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
  dirLight.position.set(100, 200, 100);
  scene.add(dirLight);

  // Create an enormous grassy ground (simulate an infinite map)
  const groundGeom = new THREE.PlaneGeometry(100000, 100000);
  const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
  const ground = new THREE.Mesh(groundGeom, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Create a long runway (20 x 1000) with a slight elevation above the ground
  const runwayGeom = new THREE.PlaneGeometry(20, 1000);
  const runwayMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
  const runway = new THREE.Mesh(runwayGeom, runwayMat);
  runway.rotation.x = -Math.PI/2;
  runway.position.set(0, 0.01, 0);
  scene.add(runway);
  createDottedLine(runway);

  // Build the airplane model (a simple blocky design)
  airplane = createAirplane();
  airplane.position.set(0, groundLevel, -400);
  scene.add(airplane);

  // Add blocky trees for scale (optional)
  createTrees(100, 2000);

  // Set up event listeners for window resize and key input
  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('keydown', (e) => { keys[e.code] = true; }, false);
  window.addEventListener('keyup', (e) => { keys[e.code] = false; }, false);
}

// Create a simple airplane using boxes
function createAirplane() {
  const group = new THREE.Group();

  // Fuselage: a central box
  const fuselageGeom = new THREE.BoxGeometry(1, 0.3, 3);
  const fuselageMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
  const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
  group.add(fuselage);

  // Wings: a wide, flat box
  const wingGeom = new THREE.BoxGeometry(4, 0.1, 1);
  const wingMat = new THREE.MeshPhongMaterial({ color: 0x0000ff });
  const wing = new THREE.Mesh(wingGeom, wingMat);
  wing.position.y = 0;
  group.add(wing);

  // Tail: a vertical stabilizer
  const tailGeom = new THREE.BoxGeometry(0.2, 0.5, 1);
  const tailMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
  const tail = new THREE.Mesh(tailGeom, tailMat);
  tail.position.set(0, 0.4, -1.5);
  group.add(tail);

  return group;
}

// Create a dotted yellow line along the center of the runway
function createDottedLine(runway) {
  const segmentGeom = new THREE.BoxGeometry(0.3, 0.01, 2);
  const segmentMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
  for (let z = -490; z < 500; z += 10) {
    const segment = new THREE.Mesh(segmentGeom, segmentMat);
    segment.position.set(0, 0.02, z);
    runway.add(segment);
  }
}

// Create a set of simple blocky trees randomly scattered in an area
function createTrees(num, area) {
  for (let i = 0; i < num; i++) {
    const tree = makeTree();
    let x = (Math.random() - 0.5) * area;
    let z = (Math.random() - 0.5) * area;
    // Avoid placing trees in the runway area
    if (Math.abs(x) < 20 && Math.abs(z) < 500) {
      i--;
      continue;
    }
    tree.position.set(x, 0, z);
    scene.add(tree);
  }
}

function makeTree() {
  const group = new THREE.Group();
  const trunkGeom = new THREE.BoxGeometry(0.5, 2, 0.5);
  const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
  const trunk = new THREE.Mesh(trunkGeom, trunkMat);
  trunk.position.y = 1;
  group.add(trunk);
  const foliageGeom = new THREE.BoxGeometry(2, 2, 2);
  const foliageMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
  const foliage = new THREE.Mesh(foliageGeom, foliageMat);
  foliage.position.y = 3;
  group.add(foliage);
  return group;
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
  requestAnimationFrame(animate);
  updateControls();
  updatePhysics();
  updateCamera();
  renderer.render(scene, camera);
}

// Update control inputs and adjust airplane orientation accordingly
function updateControls() {
  // Throttle controls
  if (keys['ArrowUp']) {
    airplaneSpeed += airplaneAcceleration;
    if (airplaneSpeed > airplaneMaxSpeed) airplaneSpeed = airplaneMaxSpeed;
  }
  if (keys['ArrowDown']) {
    airplaneSpeed -= airplaneAcceleration;
    if (airplaneSpeed < 0) airplaneSpeed = 0;
  }
  
  // Pitch control:
  // W => pitch nose down (increase rotation.x)
  // S => pitch nose up (decrease rotation.x)
  if (keys['KeyW']) {
    airplane.rotation.x += controlDelta;
  }
  if (keys['KeyS']) {
    airplane.rotation.x -= controlDelta;
  }
  
  // Roll control:
  // A => roll left (decrease rotation.z)
  // D => roll right (increase rotation.z)
  if (keys['KeyA']) {
    airplane.rotation.z -= controlDelta;
  }
  if (keys['KeyD']) {
    airplane.rotation.z += controlDelta;
  }
  
  // Automatic yaw: bank the plane in the direction of roll.
  // A positive roll (right tilt) will turn the plane right and vice versa.
  airplane.rotation.y += airplane.rotation.z * yawFactor;
  
  // Damping: when no input is given, gradually return pitch and roll to level (0)
  if (!keys['KeyW'] && !keys['KeyS']) {
    airplane.rotation.x *= pitchDamping;
  }
  if (!keys['KeyA'] && !keys['KeyD']) {
    airplane.rotation.z *= rollDamping;
  }
}

// Update airplane physics: horizontal movement (based on yaw) and vertical movement (based on pitch & gravity)
function updatePhysics() {
  // Horizontal movement: use yaw angle only.
  const yaw = airplane.rotation.y;
  const dx = Math.sin(yaw) * airplaneSpeed;
  const dz = Math.cos(yaw) * airplaneSpeed;
  airplane.position.x += dx;
  airplane.position.z += dz;
  
  // Vertical movement:
  // When the nose is up (rotation.x negative), we want to climb; when nose is down, descend.
  // Compute vertical acceleration from pitch and gravity.
  const verticalAcc = (-airplane.rotation.x * pitchInfluence) + gravity;
  verticalVelocity += verticalAcc;
  airplane.position.y += verticalVelocity;
  
  // Prevent the airplane from going below ground level.
  if (airplane.position.y < groundLevel) {
    airplane.position.y = groundLevel;
    verticalVelocity = 0;
  }
}

// Update a simple chase camera that follows behind and above the airplane.
function updateCamera() {
  // Define an offset (in airplane-local space) for the camera.
  const offset = new THREE.Vector3(0, 3, -10);
  // Compute a rotated offset using the airplane's yaw.
  const yaw = airplane.rotation.y;
  const cosY = Math.cos(yaw);
  const sinY = Math.sin(yaw);
  const worldOffset = new THREE.Vector3(
    offset.x * cosY - offset.z * sinY,
    offset.y,
    offset.x * sinY + offset.z * cosY
  );
  const desiredPos = new THREE.Vector3().copy(airplane.position).add(worldOffset);
  camera.position.lerp(desiredPos, 0.1);
  camera.lookAt(airplane.position);
}
</script>
</body>
</html>
