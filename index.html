<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Simple Mobile Flight Game</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #87ceeb; /* Sky blue background */
      touch-action: none;
    }
    #game {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    /* Transparent touch zones for virtual joysticks */
    .joystick {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 10;
    }
    #leftJoystick {
      left: 0;
    }
    #rightJoystick {
      right: 0;
    }
    /* Overlay message if in portrait mode */
    #rotateMsg {
      display: none;
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: #fff;
      font-size: 24px;
      text-align: center;
      padding-top: 40%;
      z-index: 20;
    }
    @media (orientation: portrait) {
      #rotateMsg { display: block; }
    }
  </style>
</head>
<body>
  <div id="game"></div>
  <div id="rotateMsg">Rotate your device to landscape</div>
  <!-- Virtual joystick zones -->
  <div id="leftJoystick" class="joystick"></div>
  <div id="rightJoystick" class="joystick"></div>
  
  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Global variables and constants
    let scene, camera, renderer, airplane;
    let lastTime = performance.now();
    const groundLevel = 1;  // minimum altitude
    let throttle = 0.5;     // initial throttle (0 to 1)
    const maxSpeed = 0.5;   // forward speed multiplier
    const gravity = 0.005;  // gravity factor for low throttle
    // Control sensitivity factors
    const rollFactor = 0.02;
    const pitchFactor = 0.02;
    const yawFactor = 0.01;
    
    // Virtual joystick variables
    let leftStart = null, leftDelta = {x: 0, y: 0};
    let rightStart = null, rightDelta = {x: 0, y: 0};
    const maxDelta = 50; // maximum pixel movement to normalize inputs
    
    // Utility: clamp a value between min and max
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    
    function init() {
      // Create scene with sky-blue background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      
      // Create renderer and attach to container
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('game').appendChild(renderer.domElement);
      
      // Create airplane group and add it to the scene
      airplane = new THREE.Group();
      scene.add(airplane);
      
      // Attach a cockpit camera to the airplane (offset behind and above)
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
      camera.position.set(0, 2, -5);
      airplane.add(camera);
      
      // Build a simple airplane model from boxes (hidden to keep a cockpit view)
      let fuselage = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.5, 3),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
      );
      fuselage.position.z = 1.5; // nose forward
      airplane.add(fuselage);
      
      let wing = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.1, 0.5),
        new THREE.MeshBasicMaterial({ color: 0x0000ff })
      );
      wing.position.z = 1;
      airplane.add(wing);
      
      // Hide the airplane model so the cockpit view isnâ€™t obstructed
      fuselage.visible = false;
      wing.visible = false;
      
      // Create a ground plane (simulate grass)
      let ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000),
        new THREE.MeshBasicMaterial({ color: 0x228B22 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = groundLevel - 0.01;
      scene.add(ground);
      
      // Create a runway in the center (a dark grey plane)
      let runway = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 200),
        new THREE.MeshBasicMaterial({ color: 0x555555 })
      );
      runway.rotation.x = -Math.PI / 2;
      runway.position.y = groundLevel + 0.01;
      scene.add(runway);
      
      // Resize listener
      window.addEventListener('resize', onWindowResize, false);
      
      // Set up touch event listeners for virtual joysticks
      setupJoystick('leftJoystick', true);
      setupJoystick('rightJoystick', false);
    }
    
    // Update renderer and camera on resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Set up a virtual joystick on a given element ID.
    // Left joystick: horizontal for roll and vertical for throttle.
    // Right joystick: vertical for pitch.
    function setupJoystick(id, isLeft) {
      const zone = document.getElementById(id);
      zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        if (isLeft) { leftStart = { x: touch.clientX, y: touch.clientY }; }
        else { rightStart = { x: touch.clientX, y: touch.clientY }; }
      }, { passive: false });
      
      zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        if (isLeft && leftStart) {
          leftDelta.x = clamp(touch.clientX - leftStart.x, -maxDelta, maxDelta);
          leftDelta.y = clamp(touch.clientY - leftStart.y, -maxDelta, maxDelta);
        } else if (!isLeft && rightStart) {
          rightDelta.x = clamp(touch.clientX - rightStart.x, -maxDelta, maxDelta);
          rightDelta.y = clamp(touch.clientY - rightStart.y, -maxDelta, maxDelta);
        }
      }, { passive: false });
      
      zone.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (isLeft) { leftStart = null; leftDelta = { x: 0, y: 0 }; }
        else { rightStart = null; rightDelta = { x: 0, y: 0 }; }
      }, { passive: false });
    }
    
    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;
      const factor = dt * 60;  // Normalize movement to ~60fps
      
      // Process virtual joystick inputs:
      // Left joystick: horizontal controls roll, vertical (inverted) controls throttle.
      const rollInput = clamp(leftDelta.x / maxDelta, -1, 1);
      const throttleInput = clamp(-leftDelta.y / maxDelta, -1, 1);
      // Right joystick: vertical controls pitch.
      const pitchInput = clamp(rightDelta.y / maxDelta, -1, 1);
      
      // Update throttle gradually
      throttle += throttleInput * 0.01;
      throttle = clamp(throttle, 0, 1);
      
      // Apply rotations to the airplane:
      // Roll (rotate around Z), Pitch (rotate around X), and passive Yaw (based on roll)
      airplane.rotateZ(-rollInput * rollFactor * factor);
      airplane.rotateX(pitchInput * pitchFactor * factor);
      airplane.rotateY(rollInput * yawFactor * factor);
      
      // Move the airplane forward in its local Z direction
      airplane.translateZ(throttle * maxSpeed * factor);
      
      // Apply simple gravity when throttle is low
      if (throttle < 0.3) {
        airplane.position.y -= gravity * factor;
      }
      // Prevent sinking below ground level
      if (airplane.position.y < groundLevel) {
        airplane.position.y = groundLevel;
      }
      
      renderer.render(scene, camera);
    }
    
    init();
    animate();
  </script>
</body>
</html>
