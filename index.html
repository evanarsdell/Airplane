<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Prevent default pinch zoom and ensure proper mobile scaling -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile Flight Simulator with Zoomable Chase Camera</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* Disable touch actions so the mobile browser doesn't pinch zoom the page */
      touch-action: none;
      background: #87CEEB; /* fallback blue sky */
      font-family: sans-serif;
    }
    /* Throttle slider container fixed to the bottom-right */
    #throttleContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
    /* Motion permission button (for iOS) */
    #motionButton {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 15px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      z-index: 10;
      cursor: pointer;
    }
  </style>
  <!-- Import map: Three.js and the GLTFLoader as ES modules -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
      }
    }
  </script>
</head>
<body>
  <!-- Button to ask for motion (accelerometer) permission on iOS -->
  <button id="motionButton">Enable Motion Controls</button>
  <!-- Throttle slider UI fixed at the bottom-right -->
  <div id="throttleContainer">
    <label for="throttle">Throttle</label>
    <input type="range" id="throttle" min="0" max="5" step="0.1" value="1">
  </div>
  <!-- All game code lives in this module script -->
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    // Global variables
    let scene, camera, renderer, plane;
    let clock, forwardSpeed = 1;
    const throttle = document.getElementById("throttle");

    // Device orientation values (in degrees)
    let deviceBeta = 0, deviceGamma = 0;

    // Camera chase settings â€“ default trailing distance and vertical offset.
    const defaultTrailingDistance = 10;
    let currentTrailingDistance = defaultTrailingDistance;
    const cameraVerticalOffset = 5;

    // Variables to detect pinch gestures (for zooming the camera distance).
    let isPinching = false;
    let initialPinchDistance = 0;
    let initialTrailingDistance = currentTrailingDistance;

    // Initialize Three.js scene, objects, and lights.
    function init() {
      // Create scene with a blue-sky background.
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);

      // Setup perspective camera.
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

      // Create WebGL renderer and set its size.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // Add lighting.
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 100, 100);
      scene.add(directionalLight);

      // Create a massive green ground for grass.
      const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
      const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Create a runway strip under the spawn point.
      const runwayWidth = 10, runwayLength = 200;
      const runwayGeometry = new THREE.PlaneGeometry(runwayWidth, runwayLength);
      const runwayMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
      runway.rotation.x = -Math.PI / 2;
      runway.position.set(0, 0.02, 0);
      scene.add(runway);

      // Load the 3D plane model from models/plane.glb.
      const loader = new GLTFLoader();
      loader.load(
        "models/plane.glb",
        function (gltf) {
          plane = gltf.scene;
          plane.position.set(0, 2, 0);
          scene.add(plane);
          // Initial camera update.
          updateCamera(0);
        },
        undefined,
        function (error) {
          console.error("An error occurred while loading the plane model:", error);
        }
      );

      clock = new THREE.Clock();
      window.addEventListener("resize", onWindowResize);
    }

    // Handle window resizing.
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Update the camera position to follow the plane with a chase-camera effect.
    // The camera is positioned behind the plane (using its forward vector)
    // with an adjustable trailing distance and a fixed vertical offset.
    function updateCamera(delta) {
      if (!plane) return;

      // When not actively pinching, gradually reset the trailing distance to default.
      if (!isPinching) {
        currentTrailingDistance = THREE.MathUtils.lerp(currentTrailingDistance, defaultTrailingDistance, delta * 0.5);
      }

      // Get the plane's forward direction.
      const forwardDir = new THREE.Vector3();
      plane.getWorldDirection(forwardDir);

      // Calculate desired camera position:
      // Start at the plane's position, add upward offset, then subtract the forward direction scaled by trailing distance.
      const desiredPosition = new THREE.Vector3().copy(plane.position)
        .add(new THREE.Vector3(0, cameraVerticalOffset, 0))
        .sub(forwardDir.multiplyScalar(currentTrailingDistance));

      // Smoothly interpolate the camera's current position toward the desired position.
      camera.position.lerp(desiredPosition, 0.1);

      // The camera should look in the forward direction.
      const desiredLookAt = new THREE.Vector3().copy(plane.position).add(forwardDir);
      camera.lookAt(desiredLookAt);
    }

    // Handle device orientation events (for tilt and steer).
    function handleOrientation(event) {
      deviceBeta = event.beta || 0;
      deviceGamma = event.gamma || 0;
    }

    // iOS requires explicit permission for DeviceOrientation events.
    const motionButton = document.getElementById("motionButton");
    motionButton.addEventListener("click", function () {
      if (typeof DeviceOrientationEvent.requestPermission === "function") {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === "granted") {
              window.addEventListener("deviceorientation", handleOrientation);
              motionButton.style.display = "none";
            }
          })
          .catch(console.error);
      } else {
        window.addEventListener("deviceorientation", handleOrientation);
        motionButton.style.display = "none";
      }
    });

    // Pinch gesture detection for zooming (adjusting trailing camera distance).
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    document.addEventListener("touchstart", function (e) {
      if (e.touches.length === 2) {
        isPinching = true;
        initialPinchDistance = getPinchDistance(e.touches);
        initialTrailingDistance = currentTrailingDistance;
      }
    }, { passive: false });

    document.addEventListener("touchmove", function (e) {
      if (isPinching && e.touches.length === 2) {
        e.preventDefault(); // Prevent native pinch-zoom of the page.
        const currentDistance = getPinchDistance(e.touches);
        const scale = currentDistance / initialPinchDistance;
        // Adjust trailing distance based on scale.
        // Moving fingers apart increases the distance (zoom out), while pinching in decreases it (zoom in).
        currentTrailingDistance = initialTrailingDistance / scale;
        // Clamp the value to a reasonable range.
        currentTrailingDistance = Math.min(Math.max(currentTrailingDistance, 5), 20);
      }
    }, { passive: false });

    document.addEventListener("touchend", function (e) {
      if (e.touches.length < 2) {
        isPinching = false;
      }
    }, { passive: false });

    // Main animation loop.
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (plane) {
        // Update forward speed from the throttle slider.
        forwardSpeed = parseFloat(throttle.value);

        // Use the device's orientation (beta and gamma) to steer the plane.
        const desiredPitch = THREE.MathUtils.degToRad(deviceBeta);
        const desiredRoll = THREE.MathUtils.degToRad(deviceGamma);

        // Apply a smooth adjustment for pitch and roll.
        plane.rotation.x = THREE.MathUtils.lerp(plane.rotation.x, desiredPitch, 0.1);
        plane.rotation.z = THREE.MathUtils.lerp(plane.rotation.z, -desiredRoll, 0.1);

        // Yaw (turning) is influenced by roll.
        plane.rotation.y -= desiredRoll * delta * 0.5;

        // Move the plane forward along its local negative Z-axis.
        const forward = new THREE.Vector3(0, 0, -1);
        forward.applyQuaternion(plane.quaternion);
        plane.position.add(forward.multiplyScalar(forwardSpeed * delta));
      }

      updateCamera(delta);
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
