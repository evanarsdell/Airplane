<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Airplane Flying Game</title>
  <style>
    /* Minimal reset and sky-blue background */
    body { margin: 0; overflow: hidden; background: #87CEEB; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Include Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Set up scene, renderer, and camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // sky blue

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a Group to represent the airplane
    const airplane = new THREE.Group();
    scene.add(airplane);

    // Create a sub-group for the airplane model.
    // We later hide this group so the cockpit view isn’t obstructed.
    const airplaneModel = new THREE.Group();
    airplane.add(airplaneModel);
    airplaneModel.visible = false; // hide model from cockpit view

    // ── Build the Airplane Model (simple shapes) ──
    // Fuselage: long red box
    const fuselageGeom = new THREE.BoxGeometry(0.2, 0.2, 1.5);
    const fuselageMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
    const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
    airplaneModel.add(fuselage);

    // Wings: flat blue rectangle
    const wingGeom = new THREE.BoxGeometry(1.5, 0.05, 0.5);
    const wingMat = new THREE.MeshLambertMaterial({ color: 0x0000ff });
    const wing = new THREE.Mesh(wingGeom, wingMat);
    wing.position.set(0, 0, 0);
    airplaneModel.add(wing);

    // Tail: vertical stabilizer (red)
    const tailVertGeom = new THREE.BoxGeometry(0.1, 0.3, 0.05);
    const tailMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
    const tailVert = new THREE.Mesh(tailVertGeom, tailMat);
    tailVert.position.set(0, 0.25, 0.75);
    airplaneModel.add(tailVert);

    // Tail: horizontal stabilizer (red)
    const tailHorGeom = new THREE.BoxGeometry(0.5, 0.05, 0.05);
    const tailHor = new THREE.Mesh(tailHorGeom, tailMat);
    tailHor.position.set(0, 0.2, 0.75);
    airplaneModel.add(tailHor);

    // ── Set Up the Cockpit Camera ──
    // Attach the camera as a child of the airplane so it moves with it.
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    airplane.add(camera);
    // Position the camera at the “pilot’s head” (offset slightly back and up)
    camera.position.set(0, 0.2, 0);

    // ── Lighting ──
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    // ── Create the World ──
    // Ground: a large flat green plane (grassy field)
    const groundGeom = new THREE.PlaneGeometry(2000, 2000);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x00aa00 });
    const ground = new THREE.Mesh(groundGeom, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Runway: a dark grey plane with a yellow dotted centerline
    const runwayGeom = new THREE.PlaneGeometry(10, 200);
    const runwayMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
    const runway = new THREE.Mesh(runwayGeom, runwayMat);
    runway.rotation.x = -Math.PI / 2;
    runway.position.y = 0.01; // slight offset to avoid z-fighting with ground
    scene.add(runway);

    // Yellow dotted centerline on the runway
    const numDashes = 20;
    const dashLength = 5;
    const dashSpacing = 5;
    const dashGeom = new THREE.BoxGeometry(0.2, 0.01, dashLength);
    const dashMat = new THREE.MeshLambertMaterial({ color: 0xffff00 });
    for (let i = -numDashes/2; i < numDashes/2; i++) {
      const dash = new THREE.Mesh(dashGeom, dashMat);
      dash.position.set(0, 0.02, i * (dashLength + dashSpacing));
      scene.add(dash);
    }

    // Add some blocky trees for scale
    for (let i = 0; i < 30; i++) {
      const tree = new THREE.Group();
      // Trunk (brown box)
      const trunkGeom = new THREE.BoxGeometry(0.5, 2, 0.5);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeom, trunkMat);
      trunk.position.y = 1;
      tree.add(trunk);
      // Foliage (green box)
      const foliageGeom = new THREE.BoxGeometry(2, 2, 2);
      const foliageMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
      const foliage = new THREE.Mesh(foliageGeom, foliageMat);
      foliage.position.y = 3;
      tree.add(foliage);
      // Position the tree randomly on the field
      tree.position.x = Math.random() * 1800 - 900;
      tree.position.z = Math.random() * 1800 - 900;
      tree.position.y = 0;
      scene.add(tree);
    }

    // ── Handle Window Resize ──
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ── Input Handling & Flight Physics ──
    const keys = {};
    document.addEventListener('keydown', (e) => { keys[e.code] = true; });
    document.addEventListener('keyup', (e) => { keys[e.code] = false; });

    // Flight parameters
    let speed = 10;         // current throttle (units/second)
    const minSpeed = 0;
    const maxSpeed = 50;
    const acceleration = 10;  // throttle change (units/second^2)
    const rotationSpeed = Math.PI / 4; // radians per second (45°/sec)
    const yawRate = 0.5;    // yaw factor based on current roll
    const gravity = 9.8;    // gravitational acceleration (units/second^2)

    const clock = new THREE.Clock();

    // ── Animation Loop ──
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Update throttle with arrow keys
      if (keys["ArrowUp"]) {
        speed += acceleration * delta;
        if (speed > maxSpeed) speed = maxSpeed;
      }
      if (keys["ArrowDown"]) {
        speed -= acceleration * delta;
        if (speed < minSpeed) speed = minSpeed;
      }

      // Update pitch controls (inverted so that pressing W makes the plane dive)
      if (keys["KeyW"]) { 
        // Pitch nose down (rotate -X so that forward vector gets a downward y component)
        airplane.rotateX(-rotationSpeed * delta);
      }
      if (keys["KeyS"]) {
        // Pitch nose up (rotate +X)
        airplane.rotateX(rotationSpeed * delta);
      }

      // Update roll controls
      if (keys["KeyA"]) {
        // Roll left (rotate -Z)
        airplane.rotateZ(-rotationSpeed * delta);
      }
      if (keys["KeyD"]) {
        // Roll right (rotate +Z)
        airplane.rotateZ(rotationSpeed * delta);
      }

      // Automatic yaw based on roll:
      // Use the current roll (airplane.rotation.z) to gradually yaw the plane.
      const roll = airplane.rotation.z;
      airplane.rotateY(-roll * yawRate * delta);

      // Compute forward movement:
      // Get the airplane's forward (negative Z in its local space)
      const forward = new THREE.Vector3();
      airplane.getWorldDirection(forward);
      forward.normalize();
      // Scale forward movement by current speed and delta
      forward.multiplyScalar(speed * delta);
      // Add gravity (always pulls downward in world space)
      forward.y -= gravity * delta;
      // Update airplane position
      airplane.position.add(forward);

      // Prevent airplane from going below a minimum altitude (ground level)
      const groundLevel = 0.5;
      if (airplane.position.y < groundLevel) {
        airplane.position.y = groundLevel;
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
