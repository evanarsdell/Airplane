<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple Cockpit View Flight Game</title>
  <style>
    /* Basic style: no margins, full screen, sky blue background */
    body {
      margin: 0;
      overflow: hidden;
      background: #87CEEB;
    }
    canvas {
      display: block;
    }
  </style>
  <!-- Include Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<script>
/*
  Simple Cockpit View Flight Game

  Controls:
    • Throttle: Up Arrow (increase) / Down Arrow (decrease)
    • Pitch: W (nose down) / S (nose up)
    • Roll: A (bank left) / D (bank right)
    • Automatic yaw is applied based on roll, so banking turns the plane.

  Movement:
    • Horizontal movement is computed from the airplane’s yaw.
    • Vertical movement is affected by the pitch angle plus a constant gravity.
    • If throttle is low or the nose is down, the plane will eventually descend.
  
  In this cockpit view the camera is attached to the airplane so you always see
  what the pilot sees.
*/

// Global scene variables
let scene, renderer;
let airplane;              // The airplane container (its transform drives movement)
let airplaneSpeed = 0;     // Forward throttle speed
const maxSpeed = 5;
const accel = 0.02;
let verticalVelocity = 0;
const gravity = -0.0025;
const pitchLiftFactor = 0.05; // How much pitch influences vertical acceleration
const groundLevel = 0.25;
const yawFromRoll = 0.02;     // Automatic yaw change from roll
const controlDelta = 0.01;    // Increment for pitch/roll per frame
const rollDamping = 0.98;     // Damping for roll when no input
const pitchDamping = 0.98;    // Damping for pitch when no input

// Input tracking
const keys = {};

// Set up scene, camera, and objects
init();
animate();

function init() {
  // Create scene and set background color (sky blue)
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);

  // Create renderer and add to document
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Add ambient and directional light
  scene.add(new THREE.AmbientLight(0x404040));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
  directionalLight.position.set(100, 200, 100);
  scene.add(directionalLight);

  // Create a huge ground to simulate an infinite map
  const groundGeom = new THREE.PlaneGeometry(100000, 100000);
  const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
  const ground = new THREE.Mesh(groundGeom, groundMat);
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // Create a long runway with a dotted yellow centerline
  const runwayGeom = new THREE.PlaneGeometry(20, 1000);
  const runwayMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
  const runway = new THREE.Mesh(runwayGeom, runwayMat);
  runway.rotation.x = -Math.PI / 2;
  runway.position.set(0, 0.01, 0);
  scene.add(runway);
  createDottedLine(runway);

  // Build the airplane (as a simple group) and attach the camera for cockpit view
  airplane = createAirplane();
  // Place the airplane on the runway
  airplane.position.set(0, groundLevel, -400);
  scene.add(airplane);

  // Create and attach the camera as a child of the airplane for a cockpit view.
  // Position the camera at a location that simulates the pilot’s eyes.
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
  camera.position.set(0, 0.2, 0.5);  // Adjust this offset as needed for your cockpit view
  camera.lookAt(new THREE.Vector3(0, 0, 1)); // Look straight ahead in local space
  airplane.add(camera);  // Attach camera to airplane so it follows its orientation

  // Add blocky trees for scale
  createTrees(100, 2000);

  // Set up event listeners for window resize and key input
  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('keydown', (e) => { keys[e.code] = true; }, false);
  window.addEventListener('keyup', (e) => { keys[e.code] = false; }, false);
}

// Create a dotted yellow center line on the runway
function createDottedLine(runway) {
  const segmentGeom = new THREE.BoxGeometry(0.3, 0.01, 2);
  const segmentMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
  for (let z = -490; z < 500; z += 10) {
    const segment = new THREE.Mesh(segmentGeom, segmentMat);
    segment.position.set(0, 0.02, z);
    runway.add(segment);
  }
}

// Build a simple airplane model using boxes
function createAirplane() {
  const group = new THREE.Group();

  // Fuselage: a central box
  const fuselageGeom = new THREE.BoxGeometry(1, 0.3, 3);
  const fuselageMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
  const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
  group.add(fuselage);

  // Wings: a wide, flat box
  const wingGeom = new THREE.BoxGeometry(4, 0.1, 1);
  const wingMat = new THREE.MeshPhongMaterial({ color: 0x0000ff });
  const wing = new THREE.Mesh(wingGeom, wingMat);
  wing.position.y = 0;
  group.add(wing);

  // Tail: a simple vertical stabilizer
  const tailGeom = new THREE.BoxGeometry(0.2, 0.5, 1);
  const tailMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
  const tail = new THREE.Mesh(tailGeom, tailMat);
  tail.position.set(0, 0.4, -1.5);
  group.add(tail);

  // Optionally, hide the airplane model so nothing obstructs the cockpit view:
  // group.visible = false;
  // (Uncomment the above line if you prefer a completely unobstructed cockpit.)

  return group;
}

// Create a set of simple blocky trees scattered randomly in an area
function createTrees(num, area) {
  for (let i = 0; i < num; i++) {
    const tree = makeTree();
    let x = (Math.random() - 0.5) * area;
    let z = (Math.random() - 0.5) * area;
    // Avoid trees in the runway area
    if (Math.abs(x) < 20 && Math.abs(z) < 500) {
      i--;
      continue;
    }
    tree.position.set(x, 0, z);
    scene.add(tree);
  }
}

function makeTree() {
  const group = new THREE.Group();
  const trunkGeom = new THREE.BoxGeometry(0.5, 2, 0.5);
  const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
  const trunk = new THREE.Mesh(trunkGeom, trunkMat);
  trunk.position.y = 1;
  group.add(trunk);
  const foliageGeom = new THREE.BoxGeometry(2, 2, 2);
  const foliageMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
  const foliage = new THREE.Mesh(foliageGeom, foliageMat);
  foliage.position.y = 3;
  group.add(foliage);
  return group;
}

function onWindowResize() {
  // Since the camera is attached to the airplane, find it and update its aspect ratio.
  airplane.children.forEach(child => {
    if (child.isPerspectiveCamera) {
      child.aspect = window.innerWidth / window.innerHeight;
      child.updateProjectionMatrix();
    }
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Main animation loop
function animate() {
  requestAnimationFrame(animate);
  updateControls();
  updatePhysics();
  renderer.render(scene, scene.children[0].children.find(child => child.isPerspectiveCamera) || scene);
}

// Update airplane orientation based on key inputs
function updateControls() {
  // Throttle control
  if (keys['ArrowUp']) {
    airplaneSpeed += accel;
    if (airplaneSpeed > maxSpeed) airplaneSpeed = maxSpeed;
  }
  if (keys['ArrowDown']) {
    airplaneSpeed -= accel;
    if (airplaneSpeed < 0) airplaneSpeed = 0;
  }
  
  // Pitch control: 
  // W -> pitch down (increases rotation.x) => nose goes lower
  // S -> pitch up (decreases rotation.x) => nose rises
  if (keys['KeyW']) {
    airplane.rotation.x += controlDelta;
  }
  if (keys['KeyS']) {
    airplane.rotation.x -= controlDelta;
  }
  
  // Roll control:
  // A -> roll left (decreases rotation.z)
  // D -> roll right (increases rotation.z)
  if (keys['KeyA']) {
    airplane.rotation.z -= controlDelta;
  }
  if (keys['KeyD']) {
    airplane.rotation.z += controlDelta;
  }
  
  // Automatic yaw adjustment based on roll: bank to turn
  airplane.rotation.y += airplane.rotation.z * yawFromRoll;
  
  // Damping: if no input, gradually level out pitch and roll
  if (!keys['KeyW'] && !keys['KeyS']) {
    airplane.rotation.x *= pitchDamping;
  }
  if (!keys['KeyA'] && !keys['KeyD']) {
    airplane.rotation.z *= rollDamping;
  }
}

// Update airplane movement using its orientation and physics
function updatePhysics() {
  // Horizontal movement: use the airplane’s yaw angle
  const yaw = airplane.rotation.y;
  const dx = Math.sin(yaw) * airplaneSpeed;
  const dz = Math.cos(yaw) * airplaneSpeed;
  airplane.position.x += dx;
  airplane.position.z += dz;
  
  // Vertical movement: influenced by pitch and gravity.
  // When the nose is up (rotation.x is negative) the plane climbs.
  const verticalAcc = (-airplane.rotation.x * pitchLiftFactor) + gravity;
  verticalVelocity += verticalAcc;
  airplane.position.y += verticalVelocity;
  
  // Prevent the airplane from going below ground level.
  if (airplane.position.y < groundLevel) {
    airplane.position.y = groundLevel;
    verticalVelocity = 0;
  }
}
</script>
</body>
</html>
